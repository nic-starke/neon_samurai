#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"
#include "protocol/protocol.h"
#include "led/rgb.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum virtmap_mode {
	/**
	 * @brief A single vmap is active at one time.
	 * The user can toggle between vmaps using a switch/command.
	 * Note that the encoder range will now map directly to the virtmap range.
	 */
	VIRTMAP_MODE_TOGGLE,

	/**
	 * @brief All vmaps are active at the same time.
	 */
	VIRTMAP_MODE_OVERLAY,

	VIRTMAP_MODE_NB,
};

enum virtmap_display_mode {
	VIRTMAP_DISPLAY_SINGLE,
	VIRTMAP_DISPLAY_OVERLAY,

	VIRTMAP_DISPLAY_NB,
};

struct virtmap {
	/**
	 * @brief The lower and upper range determine the numerical values that will
	 * be generated by the virtual encoder as it is rotated.
	 *
	 * E.g if the lower value is 1000 and the upper value is 5000, then the
	 * virtual encoder will output the value 1000 at the position.start point
	 * (see position struct below) and the value 5000 at the position.stop
	 * point.
	 *
	 * Every intermediate point is linearly interpolated, so halfway between
	 * start and stop would output a value of 3000 in this  example.
	 *
	 * Note that if the lower value is greater than the upper value then
	 * the generated values will be in reverse order, i.e the output
	 * will start at 5000 and reduce as the encoder is rotated clockwise.
	 *
	 * Note that the upper and lower values should be within the range
	 * defined for the protocol to be used. For example, if the protocol is
	 * configured for midi CC then there is no point in using a range above
	 * 127 or below 0.
	 */
	struct {
		i8 lower;
		i8 upper;
	} range;

	/**
	 * @brief The start and stop position are the absolute values determining
	 * where the virtual encoder begins and ends on the physical encoder
	 * rotation. E.g if the start value is 0% and the stop value is 50% then the
	 * virtual encoder will only operate from 0 degrees to 180 degrees
	 * (midpoint) of the physical encoder.
	 *
	 * Note that the start and stop values are not percentages, they are a
	 * 8-bit value. To calculate percentages use the appropriate defines for
	 * min/max encoder value.
	 */
	struct {
		u8 start;
		u8 stop;
	} position;

	u8					curr_pos;
	i16					curr_val;
	struct proto_cfg cfg;

	struct rgb_8 rgb;
	struct rb_8	rb;
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
