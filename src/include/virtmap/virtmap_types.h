#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "core/core_types.h"
#include "protocol/protocol.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

typedef enum {
	/**
	 * @brief A single vmap is active at one time.
	 * The user can toggle between vmaps using a switch/command.
	 * Note that the encoder range will now map directly to the virtmap range.
	 */
	VIRTMAP_MODE_TOGGLE,

	/**
	 * @brief All vmaps are active at the same time.
	 */
	VIRTMAP_MODE_OVERLAY,

	VIRTMAP_MODE_NB,
} virtmap_mode_e;

typedef struct virtmap_s {
	/**
	 * @brief The lower and upper range determine the numerical values that will
	 * be generated by the virtual encoder as it is rotated.
	 *
	 * E.g if the lower value is 1000 and the upper value is 5000, then the
	 * virtual encoder will output the value 1000 at the position.start point
	 * (see position struct below) and the value 5000 at the position.stop point.
	 *
	 * Every intermediate point is linearly interpolated, so halfway between
	 * start and stop would output a value of  3000 in this  example.
	 *
	 * Note that if the lower value is greater than the upper value then
	 * the generated values will be in reverse order, i.e the output
	 * will start at 5000 and reduce as the encoder is rotated clockwise.
	 *
	 * Note that the upper and lower values should be within the range
	 * defined for the protocol to be used. For example, if the protocol is
	 * configured for midi CC then there is no point in using a range above
	 * 127 or below 0.
	 */
	struct {
		i16 lower;
		i16 upper;
	} range;

	/**
	 * @brief The start and stop position are the absolute values determining
	 * where the virtual encoder begins and ends on the physical encoder rotation.
	 * E.g if the start value is 0% and the stop value is 50% then the virtual
	 * encoder will only operate from 0 degrees to 180 degrees (midpoint) of the
	 * physical encoder.
	 *
	 * Note that the start and stop values are not percentages, they are a 16-bit
	 * value. To calculate percentages use the appropriate defines for
	 * min/max encoder value.
	 */
	struct {
		u16 start;
		u16 stop;
	} position;

	u16								curr_value;
	u16								prev_value;
	proto_cfg_s				proto;
	struct virtmap_s* next;
} virtmap_s;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
