// filepath: ./lfo/lfo.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "lfo/lfo.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./io/input_manager.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <stdio.h>

#include "system/config.h"
#include "system/error.h"
#include "system/print.h"
#include "system/time.h"
#include "io/encoder.h"
#include "event/event.h"
#include "event/io.h"
#include "event/midi.h"
#include "event/sys.h"

#include "system/hardware.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

static void sw_encoder_init(void);
static void sw_encoder_update(void);
static void sw_side_switch_init(void);
static void sw_side_switch_update(void);
static void vmap_update(struct encoder* enc, struct virtmap* map);
static int	midi_in_handler(void* evt);
static void print_dir(uint enc_idx, int dir);
static void rgb_init(void);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */

EVT_HANDLER(1, evt_midi, midi_in_handler);

struct encoder		 gENCODERS[NUM_ENC_BANKS][NUM_ENCODERS];
struct side_switch gSIDE_SWITCHES[NUM_SIDE_SWITCHES];

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

void input_init(void) {
	hw_encoder_init();
	hw_switch_init();
	sw_encoder_init();
	sw_side_switch_init();
	event_channel_subscribe(EVENT_CHANNEL_MIDI_IN, &evt_midi);
}

void input_update(void) {
	hw_encoder_scan();
	hw_switch_update();
	sw_encoder_update();
	sw_side_switch_update();
}

bool is_reset_pressed(void) {
	return hw_enc_switch_state(2) == SWITCH_PRESSED &&
				 hw_enc_switch_state(3) == SWITCH_PRESSED;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */

static void sw_encoder_init(void) {
	// Initialise encoder devices and virtual parameter mappings
	enum midi_cc cc = MIDI_CC_MIN;
	for (uint b = 0; b < NUM_ENC_BANKS; b++) {
		for (uint e = 0; e < NUM_ENCODERS; e++) {
			struct encoder* enc = &gENCODERS[b][e];

			encoder_movement_init(&enc->enc_ctx);
			enc->idx							= (u8)e;
			enc->quad_ctx					= &gQUAD_ENC[e];
			enc->display.mode			= DIS_MODE_MULTI_PWM;
			enc->display.virtmode = VIRTMAP_DISPLAY_OVERLAY;
			enc->vmap_mode				= VIRTMAP_MODE_TOGGLE;
			enc->vmap_active			= 0;
			enc->sw_mode					= SW_MODE_VMAP_CYCLE;
			enc->sw_state					= SWITCH_IDLE;

			// Defaults
			// Row 1 (idx = 0,1,2,3) = pan encoder (detent true)
			// Row 2 (idx = 4,5,6,7) = filter encoder (detent true)
			// Row 3 (idx = 8,9,10,11) = send encoder (detent false)
			// Row 4 (idx = 12,13,14,15) = volume filter encoder (detent false)

			if (enc->idx < 4) {
				enc->detent				= true;
				enc->display.mode = DIS_MODE_SINGLE;
			} else if (enc->idx < 8) {
				enc->detent				= true;
				enc->display.mode = DIS_MODE_MULTI_PWM;
			} else if (enc->idx < 12) {
				enc->detent				= false;
				enc->display.mode = DIS_MODE_SINGLE;
			} else {
				enc->detent				= false;
				enc->display.mode = DIS_MODE_MULTI;
			}

			for (uint v = 0; v < NUM_VMAPS_PER_ENC; v++) {
				struct virtmap* map		= &enc->vmaps[v];
				map->position.start		= ENC_MIN;
				map->position.stop		= ENC_MAX;
				map->range.lower			= MIDI_CC_MIN;
				map->range.upper			= MIDI_CC_MAX;
				map->cfg.midi.mode		= MIDI_MODE_CC;
				map->cfg.type					= PROTOCOL_MIDI;
				map->cfg.midi.channel = 0;
				map->cfg.midi.cc			= cc++;

				// Set initial HSV values based on encoder index
				// This will create a nice color gradient across encoders
				// The hue value range is 0-1536 (0-360 degrees in 16-bit)
				// The value 0 = red, and 1536 = red again

				// Set the hue based on the encoder index
				map->hsv.hue				= (u16)(enc->idx * 96);
				map->hsv.saturation = 255;
				map->hsv.value			= 255;

				// Update RGB values from HSV values
				color_update_vmap_rgb(map);

				// Assign RB (red/blue detent LEDs) based on encoder index
				if (enc->detent) {
					map->curr_pos = ENC_MID;
					// Assign RB based on encoder index
					if (enc->idx < 4) {
						map->rb.red	 = 0x1F;
						map->rb.blue = 0x00;
					} else if (enc->idx < 8) {
						map->rb.red	 = 0x0F;
						map->rb.blue = 0x1F;
					} else if (enc->idx < 12) {
						map->rb.red	 = 0x00;
						map->rb.blue = 0x1F;
					} else {
						map->rb.red	 = 0x1F;
						map->rb.blue = 0x1F;
					}
				}
			}
		}
	}
}

static void sw_encoder_update(void) {
	for (uint i = 0; i < NUM_ENCODERS; i++) {
		struct encoder* enc = &gENCODERS[gRT.curr_bank][i];

		enc->sw_state = hw_enc_switch_state(enc->idx);

		if (enc->sw_state == SWITCH_PRESSED) {
			switch (enc->sw_mode) {
				case SW_MODE_NONE: {
					break;
				}

				case SW_MODE_VMAP_CYCLE: {
					enc->vmap_active = (enc->vmap_active + 1) % NUM_VMAPS_PER_ENC;
					mf_draw_encoder(enc);
					break;
				}

				case SW_MODE_VMAP_HOLD: {
					// ?
					break;
				}

				case SW_MODE_RESET_ON_PRESS: {
					enc->vmaps[enc->vmap_active].curr_pos = 0;
					break;
				}

				case SW_MODE_RESET_ON_RELEASE: {
					break;
				}

				case SW_MODE_FINE_ADJUST_TOGGLE: {
					break;
				}

				case SW_MODE_FINE_ADJUST_HOLD: {
					break;
				}

				default: break;
			}

			enc->sw_state = SWITCH_IDLE;
		} else if (enc->sw_state == SWITCH_RELEASED) {
			switch (enc->sw_mode) {
				case SW_MODE_NONE: {
					break;
				}

				case SW_MODE_VMAP_CYCLE: {
					break;
				}

				case SW_MODE_VMAP_HOLD: {
					// ?
					break;
				}

				case SW_MODE_RESET_ON_PRESS: {
					break;
				}

				case SW_MODE_RESET_ON_RELEASE: {
					enc->vmaps[enc->vmap_active].curr_pos = 0;
					break;
				}

				case SW_MODE_FINE_ADJUST_TOGGLE: {
					break;
				}

				case SW_MODE_FINE_ADJUST_HOLD: {
					break;
				}

				default: break;
			}
			enc->sw_state = SWITCH_IDLE;
		}

		int	 dir	 = quadrature_direction(enc->quad_ctx);
		bool moved = encoder_movement_update(&enc->enc_ctx, dir);

		if (!moved) {
			continue;
		}

		if (enc->vmap_mode == VIRTMAP_MODE_TOGGLE) {
			vmap_update(enc, &enc->vmaps[enc->vmap_active]);
		} else {
			for (uint v = 0; v < NUM_VMAPS_PER_ENC; v++) {
				vmap_update(enc, &enc->vmaps[v]);
			}
		}

		/*
			At this point the encoder was moved, and we have calculated a new
			position, and values for each of its virtual mappings. Now we need
			to update the display.
			The
		*/

		if (enc->update_display == 0) {
			enc->update_display = systime_ms();
		}
	}
}

static void vmap_update(struct encoder* enc, struct virtmap* vmap) {
	i16 newpos = vmap->curr_pos + enc->enc_ctx.velocity;
	newpos		 = CLAMP(newpos, ENC_MIN, ENC_MAX);
	newpos		 = CLAMP(newpos, vmap->position.start, vmap->position.stop);

	if ((vmap->curr_pos == newpos) ||
			!(IN_RANGE(newpos, vmap->position.start, vmap->position.stop))) {
		return;
	}

	vmap->curr_pos = (u8)newpos;

	switch (vmap->cfg.type) {

		case PROTOCOL_MIDI: {
			switch (vmap->cfg.midi.mode) {
				case MIDI_MODE_DISABLED: {
					break;
				}

				case MIDI_MODE_CC: {
					bool invert = (vmap->range.lower > vmap->range.upper);

					i16 val = convert_range_i16(vmap->curr_pos, vmap->position.start,
																			vmap->position.stop, vmap->range.lower,
																			vmap->range.upper);

					if (invert) {
						val = MIDI_CC_MAX - val;
					}

					if (vmap->curr_val == val) {
						break;
					}

					vmap->curr_val = val;

					midi_event_s midi_evt;
					midi_evt.type						 = MIDI_EVENT_CC;
					midi_evt.data.cc.channel = vmap->cfg.midi.channel;
					midi_evt.data.cc.control = vmap->cfg.midi.cc;
					midi_evt.data.cc.value	 = val & MIDI_CC_MAX;
					event_post(EVENT_CHANNEL_MIDI_OUT, &midi_evt);
					break;
				}

				case MIDI_MODE_CC_14: {
					bool invert = (vmap->range.lower > vmap->range.upper);

					i16 val = convert_range_i16(vmap->curr_pos, vmap->position.start,
																			vmap->position.stop, vmap->range.lower,
																			vmap->range.upper);

					if (invert) {
						val = 0x3FFF - val;
					}

					if (vmap->curr_val == val) {
						break;
					}

					vmap->curr_val = val;

					midi_event_s midi_evt;
					// Send the MSB
					midi_evt.type						 = MIDI_EVENT_CC;
					midi_evt.data.cc.channel = vmap->cfg.midi.channel;
					midi_evt.data.cc.control = vmap->cfg.midi.cc;
					midi_evt.data.cc.value	 = (val >> 7) & 0x7F;
					event_post(EVENT_CHANNEL_MIDI_OUT, &midi_evt);

					// Then the LSB
					midi_evt.data.cc.control = (u8)vmap->cfg.midi.cc + 32;
					midi_evt.data.cc.value	 = val & 0x7F;
					event_post(EVENT_CHANNEL_MIDI_OUT, &midi_evt);
					break;
				}

				case MIDI_MODE_REL_CC: {
					break;
				}
				case MIDI_MODE_NOTE: {
					break;
				}
			}

			break;
		}

		case PROTOCOL_OSC: {
			break;
		}

		case PROTOCOL_NONE:
		default: break;
	}
}

static int midi_in_handler(void* evt) {
	midi_event_s* midi = (midi_event_s*)evt;

	switch (midi->type) {
		case MIDI_EVENT_CC: {
			for (uint b = 0; b < NUM_ENC_BANKS; b++) {
				for (uint e = 0; e < NUM_ENCODERS; e++) {
					struct encoder* enc = &gENCODERS[b][e];

					for (int v = 0; v < NUM_VMAPS_PER_ENC; v++) {
						struct virtmap* vmap = &enc->vmaps[v];
						if (vmap->cfg.type != PROTOCOL_MIDI) {
							continue;
						} else if (vmap->cfg.midi.channel != midi->data.cc.channel) {
							continue;
						} else if (vmap->cfg.midi.cc != midi->data.cc.control) {
							continue;
						}

						// do not update if the encoder is moving.
						if (enc->enc_ctx.velocity != 0) {
							continue;
						}
						u16 newpos = (u16)convert_range_i16(
								midi->data.cc.value, vmap->range.lower, vmap->range.upper,
								vmap->position.start, vmap->position.stop);

						vmap->curr_pos = newpos;
					}
				}
			}

			break;
		}
	}

	return 0;
}

static void sw_side_switch_init(void) {
	// Initialize side switches with their default modes
	// L1 (index 0): Cycle all encoder vmaps
	gSIDE_SWITCHES[0].mode	= SIDE_SW_MODE_BANK_NEXT;
	gSIDE_SWITCHES[0].state = SWITCH_IDLE;

	// R1 (index 3): Hold to temporarily change all encoder vmaps
	gSIDE_SWITCHES[3].mode	= SIDE_SW_MODE_BANK_PREV;
	gSIDE_SWITCHES[3].state = SWITCH_IDLE;

	// L2 (index 1): Decrease bank
	gSIDE_SWITCHES[1].mode	= SIDE_SW_MODE_BANK_PREV;
	gSIDE_SWITCHES[1].state = SWITCH_IDLE;

	// R2 (index 4): Increase bank
	gSIDE_SWITCHES[4].mode	= SIDE_SW_MODE_BANK_NEXT;
	gSIDE_SWITCHES[4].state = SWITCH_IDLE;

	// L3 and R3 (index 2, 5): Reserved for future use
	gSIDE_SWITCHES[2].mode	= SIDE_SW_MODE_NONE;
	gSIDE_SWITCHES[2].state = SWITCH_IDLE;
	gSIDE_SWITCHES[5].mode	= SIDE_SW_MODE_NONE;
	gSIDE_SWITCHES[5].state = SWITCH_IDLE;
}

static void sw_side_switch_update(void) {
	// For each side switch, handle actions according to its mode and current
	// state
	for (u8 i = 0; i < NUM_SIDE_SWITCHES; i++) {

		enum switch_state state = hw_side_switch_state(i);

		if (state == SWITCH_PRESSED) {
			switch (gSIDE_SWITCHES[i].mode) {
				case SIDE_SW_MODE_NONE:
					// Do nothing
					break;

				case SIDE_SW_MODE_ALL_VMAP_CYCLE:
					// Cycle vmaps on all encoders
					for (u8 e = 0; e < NUM_ENCODERS; e++) {
						struct encoder* enc = &gENCODERS[gRT.curr_bank][e];
						enc->vmap_active		= (enc->vmap_active + 1) % NUM_VMAPS_PER_ENC;
						mf_draw_encoder(enc);
					}
					break;

				case SIDE_SW_MODE_ALL_VMAP_HOLD:
					// Store current vmap for each encoder to restore later
					for (u8 e = 0; e < NUM_ENCODERS; e++) {
						struct encoder* enc = &gENCODERS[gRT.curr_bank][e];
						gSIDE_SWITCHES[i].prev_vmap_active[e] = enc->vmap_active;
						enc->vmap_active = (enc->vmap_active + 1) % NUM_VMAPS_PER_ENC;
						mf_draw_encoder(enc);
					}
					break;

				case SIDE_SW_MODE_BANK_PREV:
					// Decrease bank index with wrapping
					if (gRT.curr_bank > 0) {
						gRT.curr_bank--;
					} else {
						gRT.curr_bank = NUM_ENC_BANKS - 1;
					}
					// Update all encoders for the new bank
					for (u8 e = 0; e < NUM_ENCODERS; e++) {
						struct encoder* enc = &gENCODERS[gRT.curr_bank][e];
						mf_draw_encoder(enc);
					}
					break;

				case SIDE_SW_MODE_BANK_NEXT:
					// Increase bank index with wrapping
					gRT.curr_bank = (gRT.curr_bank + 1) % NUM_ENC_BANKS;
					// Update all encoders for the new bank
					for (u8 e = 0; e < NUM_ENCODERS; e++) {
						struct encoder* enc = &gENCODERS[gRT.curr_bank][e];
						mf_draw_encoder(enc);
					}
					break;

				case SIDE_SW_MODE_RESERVED:
					// Reserved for future use
					break;
			}
		} else if (state == SWITCH_RELEASED) {
			switch (gSIDE_SWITCHES[i].mode) {
				case SIDE_SW_MODE_ALL_VMAP_HOLD:
					// Restore original vmap for each encoder
					for (u8 e = 0; e < NUM_ENCODERS; e++) {
						struct encoder* enc = &gENCODERS[gRT.curr_bank][e];
						enc->vmap_active		= gSIDE_SWITCHES[i].prev_vmap_active[e];
						mf_draw_encoder(enc);
					}
					break;

				default:
					// Most switch modes don't need action on release
					break;
			}
		}
	}
}
// filepath: ./io/hw_switch.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~  /
	The side switches are connected to the gpio pins PA0-PA5, and can therefore
	be read using the GPIO peripheral. The switches are active low, meaning that
	when the switch is pressed, the pin is pulled low. The switches are pulled
	up by default, so when the switch is not pressed, the pin is high.

	The pin mapping is as follows:

	SIDE_SW6 -> PORTA Pin 5)
	SIDE_SW5 -> PORTA Pin 4)
	SIDE_SW4 -> PORTA Pin 3)
	SIDE_SW3 -> PORTA Pin 0)
	SIDE_SW2 -> PORTA Pin 1)
	SIDE_SW1 -> PORTA Pin 2)

*/

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <avr/io.h>

#include "hal/gpio.h"
#include "system/hardware.h"
#include "console/console.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define PORT_SW (PORTA) // IO port for side-switches

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */

static struct switch_x8_ctx switch_ctx;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

void hw_switch_init(void) {
	// Configure gpios for side switches
	for (u8 i = 0; i < NUM_SIDE_SWITCHES; ++i) {
		gpio_dir(&PORT_SW, i, GPIO_INPUT);
		gpio_mode(&PORT_SW, i, PORT_OPC_PULLUP_gc);
	}
}

void hw_switch_update(void) {
	// Read the GPIO states for all side switches
	u8 switch_states = 0;

	// Read each switch and set corresponding bit in the switch_states bitfield
	// Side switches are active low (pulled up by default, press connects to ground)
	for (int i = 0; i < NUM_SIDE_SWITCHES; i++) {
		// Read switch: logical NOT because switches are active low
		u8 sw_state = gpio_get(&PORT_SW, i);
		switch_states |= (sw_state ? 0 : (1 << i));
	}

	// Update the switch context with the new GPIO states
	switch_x8_update(&switch_ctx, switch_states);
}

enum switch_state hw_side_switch_state(u8 idx) {
	assert(idx < NUM_SIDE_SWITCHES);

	char msg[32];
	if (switchx8_was_pressed(&switch_ctx, idx)) {
		// print a message to the console
		snprintf(msg, sizeof(msg), "Side switch %d pressed\n", idx);
		console_puts(msg);
		return SWITCH_PRESSED;
	} else if (switchx8_was_released(&switch_ctx, idx)) {
		// print a message to the console
		snprintf(msg, sizeof(msg), "Side switch %d released\n", idx);
		console_puts(msg);
		return SWITCH_RELEASED;
	} else {
		return SWITCH_IDLE;
	}
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./io/io.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "event/event.h"
#include "event/io.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define IO_EVENT_QUEUE_SIZE 32

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */

static struct io_event io_event_queue[IO_EVENT_QUEUE_SIZE];

struct event_channel io_event_ch = {
		.queue			= (u8*)io_event_queue,
		.queue_size = IO_EVENT_QUEUE_SIZE,
		.data_size	= sizeof(struct io_event),
		.handlers		= NULL,
		.onehandler = false,
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./io/switch.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "io/switch.h"
#include "system/types.h"
#include "event/io.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

// Get the state of a single switch
enum switch_state switch_x16_state(struct switch_x16_ctx* ctx, u8 index) {
	return (ctx->current & (1u << index));
}

enum switch_state switch_x8_state(struct switch_x8_ctx* ctx, u8 index) {
	return (ctx->current & (1u << index));
}

// Get the state of all switches as a bitfield
u16 switch_x16_states(struct switch_x16_ctx* ctx) {
	return (ctx->current);
}

u8 switch_x8_states(struct switch_x8_ctx* ctx) {
	return (ctx->current);
}

inline bool switchx16_was_pressed(struct switch_x16_ctx* ctx, u8 index) {
	return (ctx->raw & ctx->current) & (1u << index);
}

inline bool switchx16_was_released(struct switch_x16_ctx* ctx, u8 index) {
	return (ctx->raw & ~ctx->current) & (1u << index);
}

inline bool switchx8_was_pressed(struct switch_x8_ctx* ctx, u8 index) {
	return (ctx->raw & ctx->current) & (1u << index);
}

inline bool switchx8_was_released(struct switch_x8_ctx* ctx, u8 index) {
	return (ctx->raw & ~ctx->current) & (1u << index);
}

// Debounce algorithm for 8 switches (call before checking switch state)
void switch_x8_debounce(struct switch_x8_ctx* ctx) {
	// Store the current state
	ctx->previous = ctx->current;
	ctx->current	= 0xFF;

	// AND the new state with EVERY debounce sample, if there was a glitch
	// then the state of the switch will revert to 0.
	for (int i = 0; i < SWITCH_DEBOUNCE_SAMPLES; ++i) {
		ctx->current &= ctx->buf[i];
	}

	// Set the raw states to XOR of new and old
	ctx->raw = ctx->current ^ ctx->previous;
}

// Debounce algorithm for 16 switches
void switch_x16_debounce(struct switch_x16_ctx* ctx) {
	// Store the current state
	ctx->previous = ctx->current;
	ctx->current	= 0xFFFF;

	// AND the new state with EVERY debounce sample, if there was a glitch
	// then the state of the switch will revert to 0.
	for (int i = 0; i < SWITCH_DEBOUNCE_SAMPLES; ++i) {
		ctx->current &= ctx->buf[i];
	}

	// Set the raw states to XOR of new and old
	ctx->raw = ctx->current ^ ctx->previous;
}

void switch_x8_update(struct switch_x8_ctx* ctx, u8 gpio_state) {
	// Update the gpio states
	ctx->buf[ctx->index] = gpio_state;

	// Increment index and wrap if index == SWITCH_DEBOUNCE_SAMPLES
	ctx->index = (u8)(ctx->index + 1) % SWITCH_DEBOUNCE_SAMPLES;

	switch_x8_debounce(ctx);
}

void switch_x16_update(struct switch_x16_ctx* ctx, u16 gpio_state) {
	// Update the gpio states
	ctx->buf[ctx->index] = gpio_state;

	// Increment index and wrap if index == SWITCH_DEBOUNCE_SAMPLES
	ctx->index = (u8)(ctx->index + 1) % SWITCH_DEBOUNCE_SAMPLES;

	switch_x16_debounce(ctx);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */

#if 0

/**
 * @brief Check if a side switch was pressed.
 * This can check all side switches, or a specific set by using a mask.
 * @param Mask - Can be used to mask which side switch to check
 * @return u8 A bitfield of the current side switch states. Note - there
 * are only 6 side switches.
 */
u8 SideSwitchWasPressed(u8 Mask) {
  return (mSideSwitchStates.raw_state & mSideSwitchStates.debounces_states) &
		 Mask;
}

/**
 * @brief Check if a side switch was released.
 * This can check all side switches, or a specific set by using a mask.
 * @param Mask - Can be used to mask which side switch to check
 * @return u8 A bitfield of the current side switch states. Note - there
 * are only 6 side switches.
 */
u8 SideSwitchWasReleased(u8 Mask) {
  return (mSideSwitchStates.raw_state & (~mSideSwitchStates.debounces_states)) &
		 Mask;
}

#endif
// filepath: ./led/led.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* Further optimized re-implementation of mf_draw_encoder using LUTs. */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <math.h>
#include <float.h>
#include <assert.h>

#include "io/encoder.h"
#include "led/led.h"
#include "system/config.h"
#include "system/error.h"
#include "system/hardware.h"
#include "system/time.h"
#include "system/utility.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

// Ensure these match the hardware bit layout assumed by encoder_led_s
#define RGB_RED_BIT				(3)
#define RGB_GREEN_BIT			(4)
#define RGB_BLUE_BIT			(2)
#define DETENT_RED_BIT		(1)
#define DETENT_BLUE_BIT		(0)

#define INDICATOR_MASK(n) (0x8000 >> ((n) - 1)) // Mask for indicator n (1-11)
#define CENTER_INDICATOR	(6)
#define CENTER_INDICATOR_MASK                                                  \
	INDICATOR_MASK(CENTER_INDICATOR) // Explicit mask for center

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

// Original union structure (used implicitly for bit positions)
typedef union {
	struct {
		u16 detent_blue	 : 1; // Bit 0
		u16 detent_red	 : 1; // Bit 1
		u16 rgb_blue		 : 1; // Bit 2
		u16 rgb_red			 : 1; // Bit 3
		u16 rgb_green		 : 1; // Bit 4
		u16 indicator_11 : 1; // Bit 5
		u16 indicator_10 : 1; // Bit 6
		u16 indicator_9	 : 1; // Bit 7
		u16 indicator_8	 : 1; // Bit 8
		u16 indicator_7	 : 1; // Bit 9
		u16 indicator_6	 : 1; // Bit 10 - Center Detent Indicator
		u16 indicator_5	 : 1; // Bit 11
		u16 indicator_4	 : 1; // Bit 12
		u16 indicator_3	 : 1; // Bit 13
		u16 indicator_2	 : 1; // Bit 14
		u16 indicator_1	 : 1; // Bit 15
	};
	u16 state;
} encoder_led_s;

/* ~~~~~~~~~~~~~~~~~~~~ Precomputed Lookup Tables (LUTs) ~~~~~~~~~~~~~~~~~~~ */

// LUT for individual indicator masks (index 0 unused)
static const u16 INDICATOR_MASKS[NUM_INDICATOR_LEDS + 1] = {
		0, // Index 0 unused
		INDICATOR_MASK(1),
		INDICATOR_MASK(2),
		INDICATOR_MASK(3),
		INDICATOR_MASK(4),
		INDICATOR_MASK(5),
		INDICATOR_MASK(6),
		INDICATOR_MASK(7),
		INDICATOR_MASK(8),
		INDICATOR_MASK(9),
		INDICATOR_MASK(10),
		INDICATOR_MASK(11),
};

// LUT for standard bar graph patterns (index 0 = off, 1-11 = LEDs 1..index ON)
static const u16 BAR_GRAPH_MASKS[NUM_INDICATOR_LEDS + 1] = {
		0x0000, // 0 LEDs
		0x8000, // 1
		0xC000, // 1-2
		0xE000, // 1-3
		0xF000, // 1-4
		0xF800, // 1-5
		0xFC00, // 1-6
		0xFE00, // 1-7
		0xFF00, // 1-8
		0xFF80, // 1-9
		0xFFC0, // 1-10
		0xFFE0	// 1-11
};

// LUT for center-out detent patterns (index 0 = off, 1-5=idx..5, 6=off,
// 7-11=7..idx)
static const u16 CENTER_OUT_MASKS[NUM_INDICATOR_LEDS + 1] = {
		0x0000, // 0 LEDs (or invalid index)
		0xF800, // 1-5 (Index 1)
		0x7800, // 2-5 (Index 2)
		0x3800, // 3-5 (Index 3)
		0x1800, // 4-5 (Index 4)
		0x0800, // 5   (Index 5)
		0x0000, // Center OFF (Index 6)
		0x0200, // 7   (Index 7)
		0x0300, // 7-8 (Index 8)
		0x0380, // 7-9 (Index 9)
		0x03C0, // 7-10 (Index 10)
		0x03E0	// 7-11 (Index 11)
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

int display_init(void) {
	// Request a display update for every encoder
	for (uint e = 0; e < NUM_ENCODERS; e++) {
		struct encoder* enc = &gENCODERS[gRT.curr_bank][e];
		enc->update_display = 1;
	}
	return 0;
}

void display_update(void) {
	u32 time_now = systime_ms();

	for (uint e = 0; e < NUM_ENCODERS; e++) {
		struct encoder* enc = &gENCODERS[gRT.curr_bank][e];

		if (enc->update_display != 0 &&
				(time_now - enc->update_display) > (500 / NUM_PWM_FRAMES)) {
			mf_draw_encoder(enc);
			enc->update_display = 0;
		}
	}
}

/**
 * @brief Draws the LED state for a given encoder. Highly optimized using LUTs.
 * @param enc Pointer to the encoder structure.
 * @return 0 on success, error code otherwise.
 */
int mf_draw_encoder(struct encoder* enc) {
	assert(enc != NULL);
	assert(enc->idx < NUM_ENCODERS);
	assert(NUM_INDICATOR_LEDS == 11); // LUTs assume this size

	// --- 1. Fetch frequently used data ---
	struct virtmap*					vmap				= &enc->vmaps[enc->vmap_active];
	const u8								current_pos = vmap->curr_pos;
	const enum display_mode mode				= enc->display.mode;
	const bool							is_detent		= enc->detent;
	const u8								enc_idx			= enc->idx;

	// --- 2. Calculate leading LED index ---
	// Map encoder position (0..ENC_MAX) -> LED index (1..NUM_INDICATOR_LEDS)
	u8 led_index;
	if (current_pos == 0) {
		led_index = 1;
	} else if (current_pos >= ENC_MAX) {
		led_index = NUM_INDICATOR_LEDS;
	} else {
		// Ceiling division: ((pos * NUM_LEDS) + MAX - 1) / MAX
		led_index = ((u32)current_pos * NUM_INDICATOR_LEDS + ENC_MAX - 1) / ENC_MAX;
		// Clamp (should be redundant if calculation is correct for pos in
		// [1..MAX-1])
		if (led_index < 1)
			led_index = 1;
		if (led_index > NUM_INDICATOR_LEDS)
			led_index = NUM_INDICATOR_LEDS;
	}

	// --- 3. Determine Base Indicator Pattern & PWM Setup ---
	u16	 base_indicator_state			= 0;
	u8	 pwm_brightness						= 0;
	u16	 led_pwm_mask							= 0; // Mask for the single LED being PWM'd
	u8	 effective_pwm_brightness = 0; // Brightness threshold for dimming check
	bool apply_pwm_dimming				= false; // Flag to enable dimming check in loop

	switch (mode) {
		case DIS_MODE_SINGLE:
			base_indicator_state = INDICATOR_MASKS[led_index];
			break;

		case DIS_MODE_MULTI_PWM:
			// Calculate PWM brightness (0 to NUM_PWM_FRAMES-1)
			if (current_pos == ENC_MAX) {
				pwm_brightness = NUM_PWM_FRAMES - 1;
			} else if (current_pos > 0) {
				u32 scaled_pos =
						((u32)current_pos * NUM_INDICATOR_LEDS * 256) / ENC_MAX;
				u16 base_pos_for_led = (led_index - 1) * 256;
				u16 pos_in_led			 = (scaled_pos >= base_pos_for_led)
																	 ? (scaled_pos - base_pos_for_led)
																	 : 0;
				pwm_brightness			 = (pos_in_led * NUM_PWM_FRAMES) >> 8;
				if (pwm_brightness >= NUM_PWM_FRAMES) {
					pwm_brightness = NUM_PWM_FRAMES - 1;
				}
			}
			// else: pwm_brightness = 0 for current_pos == 0

			// Setup for PWM dimming in the loop
			led_pwm_mask						 = INDICATOR_MASKS[led_index];
			effective_pwm_brightness = pwm_brightness;
			apply_pwm_dimming				 = true; // Enable the dimming check

			// Apply brightness inversion quirk for detent mode, left side
			if (is_detent && led_index < CENTER_INDICATOR) {
				effective_pwm_brightness = (NUM_PWM_FRAMES - 1) - pwm_brightness;
			}
			// fallthrough

		case DIS_MODE_MULTI:
			// Lookup base pattern from LUT
			base_indicator_state =
					is_detent ? CENTER_OUT_MASKS[led_index] : BAR_GRAPH_MASKS[led_index];
			break;

		default: return ERR_BAD_PARAM;
	}

	if (is_detent) {
		base_indicator_state &= ~CENTER_INDICATOR_MASK;
	}

	// --- 4. Pre-fetch BCM Brightness Values ---
	const u8 rgb_r = vmap->rgb.red;
	const u8 rgb_g = vmap->rgb.green;
	const u8 rgb_b = vmap->rgb.blue;
	const u8 det_r = is_detent ? vmap->rb.red : 0;
	const u8 det_b = is_detent ? vmap->rb.blue : 0;

	// --- 5. Generate PWM/BCM frames ---
	for (unsigned int f = 0; f < NUM_PWM_FRAMES; ++f) {
		// Start with the base indicator pattern for this frame
		u16 current_indicator_state = base_indicator_state;

		// Apply PWM dimming if needed (turn OFF leading LED if frame >= brightness)
		if (apply_pwm_dimming && (f >= effective_pwm_brightness)) {
			current_indicator_state &= ~led_pwm_mask;
		}

		// Calculate BCM bits for this frame (directly build the lower part of the
		// state)
		u16 current_bcm_bits = 0;
		if (rgb_r > f)
			current_bcm_bits |= (1 << RGB_RED_BIT);
		if (rgb_g > f)
			current_bcm_bits |= (1 << RGB_GREEN_BIT);
		if (rgb_b > f)
			current_bcm_bits |= (1 << RGB_BLUE_BIT);
		// Detent BCM bits are only added if is_detent is true (det_r/det_b are 0
		// otherwise)
		if (det_r > f)
			current_bcm_bits |= (1 << DETENT_RED_BIT);
		if (det_b > f)
			current_bcm_bits |= (1 << DETENT_BLUE_BIT);

		// Combine indicator state and BCM bits
		u16 final_state = current_indicator_state | current_bcm_bits;

		// --- 6. Write to Frame Buffer (Inverted) ---
		gFRAME_BUFFER[f][enc_idx] = ~final_state;
	}

	return 0; // Success
}
// filepath: ./led/hsv2rgb.c
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2016  B. Stultiens
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
#include "led/hsv2rgb.h"

#if defined(HSV_USE_ASSEMBLY) && !defined(__AVR_ARCH__)
#warning "Only AVR assembly is implemented. Other architectures use C fallback."
#undef HSV_USE_ASSEMBLY
#endif

void fast_hsv2rgb_8bit(uint16_t h, uint8_t s, uint8_t v, uint8_t* r, uint8_t* g,
											 uint8_t* b) {
#ifndef HSV_USE_ASSEMBLY
	HSV_MONOCHROMATIC_TEST(s, v, r, g, b); // Exit with grayscale if s == 0

	uint8_t sextant = h >> 8;

	HSV_SEXTANT_TEST(sextant); // Optional: Limit hue sextants to defined space

	HSV_POINTER_SWAP(sextant, r, g,
									 b); // Swap pointers depending which sextant we are in

	*g = v; // Top level

	// Perform actual calculations
	uint8_t	 bb;
	uint16_t ww;

	/*
	 * Bottom level: v * (1.0 - s)
	 * --> (v * (255 - s) + error_corr) / 256
	 */
	bb = ~s;
	ww = v * bb;
	ww += 1;			 // Error correction
	ww += ww >> 8; // Error correction
	*b = ww >> 8;

	uint8_t h_fraction = h & 0xff; // 0...255

	if (!(sextant & 1)) {
		// *r = ...slope_up...;
		/*
		 * Slope up: v * (1.0 - s * (1.0 - h))
		 * --> (v * (255 - (s * (256 - h) + error_corr1) / 256) + error_corr2) / 256
		 */
		ww = !h_fraction ? ((uint16_t)s << 8) : (s * (uint8_t)(-h_fraction));
		ww += ww >> 8; // Error correction 1
		bb = ww >> 8;
		bb = ~bb;
		ww = v * bb;
		ww += v >> 1; // Error correction 2
		*r = ww >> 8;
	} else {
		// *r = ...slope_down...;
		/*
		 * Slope down: v * (1.0 - s * h)
		 * --> (v * (255 - (s * h + error_corr1) / 256) + error_corr2) / 256
		 */
		ww = s * h_fraction;
		ww += ww >> 8; // Error correction 1
		bb = ww >> 8;
		bb = ~bb;
		ww = v * bb;
		ww += v >> 1; // Error correction 2
		*r = ww >> 8;

		/*
		 * A perfect match for h_fraction == 0 implies:
		 *	*r = (ww >> 8) + (h_fraction ? 0 : 1)
		 * However, this is an extra calculation that may not be required.
		 */
	}

#else /* HSV_USE_ASSEMBLY */

#ifdef __AVR_ARCH__
	/*
	 * Function arguments passed in registers:
	 *   h = r25:r24
	 *   s = r22
	 *   v = r20
	 *   *r = r19:r18
	 *   *g = r17:r16
	 *   *b = r15:r14
	 */
	__asm__ volatile(
			MOVW("r27", "r26", "r19", "r18") // r -> X
			MOVW("r29", "r28", "r17", "r16") // g -> Y
			MOVW("r31", "r30", "r15", "r14") // b -> Z

			"cpse	r22, __zero_reg__\n\t" // if(!s) --> monochromatic
			"rjmp	.Lneedcalc%=\n\t"

			"st	X, r20\n\t" // *r = *g = *b = v;
			"st	Y, r20\n\t"
			"st	Z, r20\n\t"
			"rjmp	.Lendoffunc%=\n" // return

			".Lneedcalc%=:\n\t"

			"cpi	r25, lo8(6)\n\t" // if(hi8(h) > 5) hi8(h) = 5;
			"brlo	.Linrange%=\n\t"
			"ldi	r25,lo8(5)\n"
			".Linrange%=:\n\t"

			"sbrs	r25, 1\n\t" // if(sextant & 2) swapptr(r, b);
			"rjmp	.Lsextno1%=\n\t" MOVW("r19", "r18", "r27", "r26") MOVW("r27", "r26",
																																	 "r31", "r30")
					MOVW("r31", "r30", "r19",
							 "r18") "\n"
											".Lsextno1%=:\n\t"

											"sbrs	r25, 2\n\t" // if(sextant & 4) swapptr(g, b);
											"rjmp	.Lsextno2%=\n\t" MOVW("r19", "r18", "r29", "r28")
													MOVW("r29", "r28", "r31", "r30") MOVW(
															"r31", "r30", "r19",
															"r18") "\n"
																		 ".Lsextno2%=:\n\t"

																		 "ldi	r18, lo8(6)\n\t"
																		 "and	r18, r25\n\t" // if(!(sextant & 6))
																		 "brne	.Lsext2345%=\n\t"

																		 "sbrc	r25, 0\n\t" // if(!(sextant & 6) &&
																												// !(sextant & 1)) -->
																												// doswasp
																		 "rjmp	.Ldoneswap%=\n"
																		 ".Lsext0%=:\n\t" MOVW("r19", "r18", "r27",
																													 "r26")
																				 MOVW("r27", "r26", "r29", "r28") MOVW(
																						 "r29", "r28", "r19",
																						 "r18") "rjmp	.Ldoneswap%=\n"

																										".Lsext2345%=:\n\t"
																										"sbrc	r25, 0\n\t" // if((sextant
																																			// & 6) &&
																																			// (sextant
																																			// & 1))
																																			// -->
																																			// doswap
																										"rjmp	.Lsext0%=\n"
																										".Ldoneswap%=:\n\t"

																										/* Top level assignment
																											 first to free up Y
																											 register (r29:r28) */
																										"st	Y, r20\n\t" // *g = v

																										"ldi	r18, 0\n\t" // Temporary
																																			// zero
																																			// reg (r1
																																			// is used
																																			// by mul)
																										"ldi	r19, 1\n\t" // Temporary
																																			// one reg

																										/*
																										 * Do bottom level next so
																										 *we may use Z register
																										 *(r31:r30).
																										 *
																										 *	Bottom level: v * (1.0 -
																										 *s)
																										 *	--> (v * (255 - s) +
																										 *error_corr + 1) / 256 1 bb
																										 *= ~s; 2 ww = v * bb; 3 ww
																										 *+= 1; 4 ww += ww >> 8;	//
																										 *error_corr for division
																										 *1/256 instead of 1/255 5
																										 **b = ww >> 8;
																										 */
																										"mov	r23, r22\n\t" // 1 use
																																				// copy
																																				// of s
																										"com	r23\n\t"			// 1
			MUL("r23", "r20", "a") // 2 r1:r0 = v *  ~s
			"add	r0, r19\n\t"		 // 3 r1:r0 += 1
			"adc	r1, r18\n\t"		 // 3
			"add	r0, r1\n\t"			 // 4 r1:r0 += r1:r0 >> 8
			"adc	r1, r18\n\t"		 // 4
			"st	Z, r1\n\t"				 // 5 *b = r1:r0 >> 8

			/* All that is left are the slopes */

			"sbrc	r25, 0\n\t" // if(sextant & 1) --> slope down
			"rjmp	.Lslopedown%=\n\t"

			/*
			 *	Slope up: v * (1.0 - s * (1.0 - h))
			 *	--> (v * (255 - (s * (256 - h) + error_corr1) / 256) + error_corr2) /
			 *256 0 ww = 256 - h_fraction; 1 ww = s * bb; 2 ww += ww >> 8;	//
			 *error_corr1 3 bb = ww >> 8;		// Implicit operation 4 bb = ~bb; 5 ww = v
			 ** bb; 6 ww += v >> 1;		// error_corr2 7 *r = ww >> 8;
			 */
			"ldi	r28, 0\n\t" // 0 256
			"ldi	r29, 1\n\t"
			"sub	r28, r24\n\t" // 0 256 - h_fraction
			"sbc	r29, r18\n\t" MUL("r28", "r22",
															"b") // 1 r1:r0 = s * (256 - h_fraction)
			"sbrc	r29, 0\n\t"						 // 1 if(256 - h_fraction == 0x100)
			"add	r1, r22\n\t"					 // 1   r1:r0 += s << 8
			"rjmp	.Lslopecommon%=\n\t"	 // r1:r0 holds inner multiplication

			/*
			 *	Slope down: v * (1.0 - s * h)
			 *	--> (v * (255 - (s * h + error_corr1) / 256) + error_corr2) / 256
			 *	1 ww = s * h_fraction;
			 *	2 ww += ww >> 8;	// error_corr1
			 *	3 bb = ww >> 8;		// Implicit operation
			 *	4 bb = ~bb;
			 *	5 ww = v * bb;
			 *	6 ww += v >> 1;		// error_corr2
			 *	7 *r = ww >> 8;
			 */
			"\n"
			".Lslopedown%=:\n\t" MUL("r24", "r22", "c") // 1 r1:r0 = s * h_fraction
			"\n"
			".Lslopecommon%=:\n\t"
			"add	r0, r1\n\t"			// 2 error_corr1
			"adc	r1, r18\n\t"		// 2
			"com	r1\n\t"					// 4 bb = ~bb
			MUL("r1", "r20", "d") // 5 r1:r0 = v * bb
			"lsr	r20\n\t"				// 6 error_corr2: v >>= 1
			"add	r0, r20\n\t"		// 6 r1:r0 += v >> 1
			"adc	r1, r18\n"			// 6
			"st	X, r1\n\t"				// 7 *r = slope result

			"clr	__zero_reg__\n" // Restore zero reg

			".Lendoffunc%=:\n"
			:
			:
			: "r31", "r30", "r29", "r28", "r27", "r26", "r25", "r24", "r22", "r19",
				"r18"
#ifndef __AVR_HAVE_MUL__
				,
				"r17", "r16"
#endif
	);
#else /* __AVR_ARCH__ */
#error "No assembly version implemented for architecture"
#endif
#endif /* HSV_USE_ASSEMBLY */
}
// filepath: ./led/color.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/**
 * @file color.c
 * @brief Implementation of the HSV color system with gamma correction
 */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "system/types.h"
#include "system/error.h"
#include "system/utility.h"
#include "system/hardware.h"
#include "console/console.h"
#include "led/color.h"
#include "led/hsv2rgb.h"
#include "io/encoder.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

extern struct encoder gENCODERS[NUM_ENC_BANKS][NUM_ENCODERS];

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */

// Gamma brightness lookup table <https://victornpb.github.io/gamma-table-generator>
// gamma = 2.20 steps = 256 range = 0-255
const uint8_t gamma_lut[256] PROGMEM = {
	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,
	1,   1,   1,   1,   1,   1,   1,   1,   1,   2,   2,   2,   2,   2,   2,   2,
	3,   3,   3,   3,   3,   4,   4,   4,   4,   5,   5,   5,   5,   6,   6,   6,
	6,   7,   7,   7,   8,   8,   8,   9,   9,   9,  10,  10,  11,  11,  11,  12,
 12,  13,  13,  13,  14,  14,  15,  15,  16,  16,  17,  17,  18,  18,  19,  19,
 20,  20,  21,  22,  22,  23,  23,  24,  25,  25,  26,  26,  27,  28,  28,  29,
 30,  30,  31,  32,  33,  33,  34,  35,  35,  36,  37,  38,  39,  39,  40,  41,
 42,  43,  43,  44,  45,  46,  47,  48,  49,  49,  50,  51,  52,  53,  54,  55,
 56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,
 73,  74,  75,  76,  77,  78,  79,  81,  82,  83,  84,  85,  87,  88,  89,  90,
 91,  93,  94,  95,  97,  98,  99, 100, 102, 103, 105, 106, 107, 109, 110, 111,
113, 114, 116, 117, 119, 120, 121, 123, 124, 126, 127, 129, 130, 132, 133, 135,
137, 138, 140, 141, 143, 145, 146, 148, 149, 151, 153, 154, 156, 158, 159, 161,
163, 165, 166, 168, 170, 172, 173, 175, 177, 179, 181, 182, 184, 186, 188, 190,
192, 194, 196, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221,
223, 225, 227, 229, 231, 234, 236, 238, 240, 242, 244, 246, 248, 251, 253, 255,
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

static struct virtmap* get_virtmap_from_indices(uint8_t bank, uint8_t enc,
																								uint8_t vmap_idx);
static void						 update_encoder_display(uint8_t bank, uint8_t enc);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief Updates RGB values from HSV color space with gamma correction
 *
 * Converts the HSV color values stored in the virtmap to RGB values,
 * then applies gamma correction to produce BCM-compatible brightness levels.
 *
 * @param vmap Pointer to the virtmap structure containing HSV color values
 */
void color_update_vmap_rgb(struct virtmap* vmap) {
	assert(vmap);

	uint8_t r_linear, g_linear, b_linear; // Temp vars for 0-255 RGB values

	// Convert HSV to linear RGB using the optimized HSV to RGB conversion
	// The function expects hue in 0-1535 range, saturation and value in 0-255
	// range
	fast_hsv2rgb_8bit(vmap->hsv.hue, vmap->hsv.saturation, vmap->hsv.value,
										&r_linear, &g_linear, &b_linear);

	// Apply gamma correction using the lookup tables
	// This maps the linear 0-255 RGB values to gamma-corrected 0-31 BCM values
	vmap->rgb.red		= pgm_read_byte(&gamma_lut[r_linear]) >> 3;
	vmap->rgb.green = pgm_read_byte(&gamma_lut[g_linear]) >> 3;
	vmap->rgb.blue	= pgm_read_byte(&gamma_lut[b_linear]) >> 3;

	// Ensure values are within the valid BCM range (0-31)
	vmap->rgb.red		= CLAMP(vmap->rgb.red, 0, NUM_PWM_FRAMES - 1);
	vmap->rgb.green = CLAMP(vmap->rgb.green, 0, NUM_PWM_FRAMES - 1);
	vmap->rgb.blue	= CLAMP(vmap->rgb.blue, 0, NUM_PWM_FRAMES - 1);
}

/**
 * @brief Sets linear RGB values with gamma correction
 *
 * Takes linear RGB values (0-255) and converts them to gamma-corrected
 * BCM values (0-31) for display on the LEDs.
 *
 * @param vmap Pointer to the virtmap structure
 * @param r_linear Red component (0-255)
 * @param g_linear Green component (0-255)
 * @param b_linear Blue component (0-255)
 */
void color_set_vmap_rgb_linear(struct virtmap* vmap, uint8_t r_linear,
															 uint8_t g_linear, uint8_t b_linear) {
	assert(vmap);

	// Apply gamma correction using the lookup tables
	vmap->rgb.red		= pgm_read_byte(&gamma_lut[r_linear]) >> 3;
	vmap->rgb.green = pgm_read_byte(&gamma_lut[g_linear]) >> 3;
	vmap->rgb.blue	= pgm_read_byte(&gamma_lut[b_linear]) >> 3;

	// Ensure values are within the valid BCM range
	vmap->rgb.red		= CLAMP(vmap->rgb.red, 0, NUM_PWM_FRAMES - 1);
	vmap->rgb.green = CLAMP(vmap->rgb.green, 0, NUM_PWM_FRAMES - 1);
	vmap->rgb.blue	= CLAMP(vmap->rgb.blue, 0, NUM_PWM_FRAMES - 1);

	// Also update the HSV values to maintain consistency
	// This is a simple approximation since RGB to HSV conversion is more complex
	// and not needed for normal operation, but helps maintain state consistency
	uint16_t max_val = MAX(r_linear, MAX(g_linear, b_linear));

	if (max_val == 0) {
		// Black color case
		vmap->hsv.hue				 = 0;
		vmap->hsv.saturation = 0;
		vmap->hsv.value			 = 0;
		return;
	}

	vmap->hsv.value = max_val;

	uint16_t min_val = MIN(r_linear, MIN(g_linear, b_linear));
	uint16_t delta	 = max_val - min_val;

	if (delta == 0) {
		// Gray color case
		vmap->hsv.hue				 = 0;
		vmap->hsv.saturation = 0;
	} else {
		vmap->hsv.saturation = (255 * delta) / max_val;

		if (r_linear == max_val) {
			vmap->hsv.hue = (((g_linear - b_linear) * 256) / delta) % 1536;
		} else if (g_linear == max_val) {
			vmap->hsv.hue = ((b_linear - r_linear) * 256) / delta + 512;
		} else {
			vmap->hsv.hue = ((r_linear - g_linear) * 256) / delta + 1024;
		}
	}
}

/**
 * @brief Sets BCM RGB values directly
 *
 * Allows direct setting of the BCM RGB values (0-31) without gamma correction.
 * This is useful for direct control of the LED brightness levels.
 *
 * @param vmap Pointer to the virtmap structure
 * @param r_bcm Red BCM value (0-31)
 * @param g_bcm Green BCM value (0-31)
 * @param b_bcm Blue BCM value (0-31)
 */
void color_set_vmap_rgb_bcm(struct virtmap* vmap, uint8_t r_bcm, uint8_t g_bcm,
														uint8_t b_bcm) {
	assert(vmap);

	// Set BCM values directly with range checking
	vmap->rgb.red		= CLAMP(r_bcm, 0, NUM_PWM_FRAMES - 1);
	vmap->rgb.green = CLAMP(g_bcm, 0, NUM_PWM_FRAMES - 1);
	vmap->rgb.blue	= CLAMP(b_bcm, 0, NUM_PWM_FRAMES - 1);

	// This function doesn't update HSV values since it's a direct BCM setter
	// This can cause state inconsistency between HSV and RGB values
	// Which is acceptable for direct BCM control use cases
}

/**
 * @brief Set HSV values for a specific virtmap and update RGB
 *
 * @param bank Bank index
 * @param enc Encoder index
 * @param vmap_idx Virtmap index
 * @param h Hue (0-1535)
 * @param s Saturation (0-255)
 * @param v Value (0-255)
 */
void color_set_vmap_hsv(uint8_t bank, uint8_t enc, uint8_t vmap_idx, uint16_t h,
												uint8_t s, uint8_t v) {
	// Get the virtmap pointer
	struct virtmap* vmap = get_virtmap_from_indices(bank, enc, vmap_idx);
	if (!vmap)
		return;

	// Clamp input values to valid ranges
	h = CLAMP(h, 0, HSV_HUE_STEPS - 1); // 0-1535
	s = CLAMP(s, 0, 255);								// 0-255
	v = CLAMP(v, 0, 255);								// 0-255

	// Set the HSV values
	vmap->hsv.hue				 = h;
	vmap->hsv.saturation = s;
	vmap->hsv.value			 = v;

	// Update the RGB values
	color_update_vmap_rgb(vmap);

	// Request display update
	update_encoder_display(bank, enc);
}

/**
 * @brief Set linear RGB values for a specific virtmap with indices
 *
 * @param bank Bank index
 * @param enc Encoder index
 * @param vmap_idx Virtmap index
 * @param r_linear Red linear value (0-255)
 * @param g_linear Green linear value (0-255)
 * @param b_linear Blue linear value (0-255)
 */
void color_set_vmap_rgb_linear_by_index(uint8_t bank, uint8_t enc,
																				uint8_t vmap_idx, uint8_t r_linear,
																				uint8_t g_linear, uint8_t b_linear) {
	// Get the virtmap pointer
	struct virtmap* vmap = get_virtmap_from_indices(bank, enc, vmap_idx);
	if (!vmap)
		return;

	// Set the RGB values with gamma correction
	color_set_vmap_rgb_linear(vmap, r_linear, g_linear, b_linear);

	// Request display update
	update_encoder_display(bank, enc);
}

/**
 * @brief Set BCM RGB values directly for a specific virtmap with indices
 *
 * @param bank Bank index
 * @param enc Encoder index
 * @param vmap_idx Virtmap index
 * @param r_bcm Red BCM value (0-31)
 * @param g_bcm Green BCM value (0-31)
 * @param b_bcm Blue BCM value (0-31)
 */
void color_set_vmap_rgb_bcm_by_index(uint8_t bank, uint8_t enc,
																		 uint8_t vmap_idx, uint8_t r_bcm,
																		 uint8_t g_bcm, uint8_t b_bcm) {
	// Get the virtmap pointer
	struct virtmap* vmap = get_virtmap_from_indices(bank, enc, vmap_idx);
	if (!vmap)
		return;

	// Set the BCM RGB values directly
	color_set_vmap_rgb_bcm(vmap, r_bcm, g_bcm, b_bcm);

	// Request display update
	update_encoder_display(bank, enc);
}

/**
 * @brief Print the gamma lookup table for a specific color channel
 *
 * @param channel Color channel ('r', 'g', or 'b')
 */
void color_print_gamma_lut(char channel) {
	char					 buffer[32];
	const uint8_t* lut = gamma_lut;

	// Print header
	console_puts_p(PSTR("Linear | Gamma | BCM\r\n"));
	console_puts_p(PSTR("------+-------+-----\r\n"));

	// Print values at regular intervals to avoid overwhelming the console
	for (uint16_t i = 0; i <= 255; i += 16) {
		uint8_t gamma_val = pgm_read_byte(&lut[i]);
		uint8_t bcm_val		= gamma_val >> 3; // Scale to 0-31 for BCM

		snprintf_P(buffer, sizeof(buffer), PSTR(" %3u  |  %3u  | %2u\r\n"), i,
							 gamma_val, bcm_val);
		console_puts(buffer);
	}
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * Helper function to get a virtmap pointer from bank, encoder, and vmap indices
 *
 * @param bank Bank index
 * @param enc Encoder index
 * @param vmap_idx Virtmap index
 * @return Pointer to the requested virtmap or NULL if indices are invalid
 */
static struct virtmap* get_virtmap_from_indices(uint8_t bank, uint8_t enc,
																								uint8_t vmap_idx) {
	// Check if indices are within valid range
	if (bank >= NUM_ENC_BANKS || enc >= NUM_ENCODERS ||
			vmap_idx >= NUM_VMAPS_PER_ENC) {
		return NULL;
	}

	// Return pointer to the virtmap
	return &gENCODERS[bank][enc].vmaps[vmap_idx];
}

/**
 * Helper function to request display update for an encoder
 *
 * @param bank Bank index
 * @param enc Encoder index
 */
static void update_encoder_display(uint8_t bank, uint8_t enc) {
	// Check if indices are within valid range
	if (bank >= NUM_ENC_BANKS || enc >= NUM_ENCODERS) {
		return;
	}

	// Mark encoder for update by setting timestamp
	// A value of 1 will trigger an immediate update on the next display_update
	// cycle
	gENCODERS[bank][enc].update_display = 1;
}
// filepath: ./led/hw_led.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <string.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/atomic.h>

#include "system/types.h"

#include "hal/gpio.h"
#include "hal/dma.h"
#include "hal/usart.h"
#include "hal/timer.h"

#include "system/hardware.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define PORT_SR_LED					(PORTD)		// IO port for led shift registers
#define USART_LED						(USARTD0) // USART on D0
#define TIMER_LED						(TCD0)		// Timer on D0
#define TIMER_PERIOD				(255)
#define SOFT_PWM_PERIOD			(32)

#define PIN_SR_LED_ENABLE_N (0)
#define PIN_SR_LED_CLOCK		(1)
#define PIN_SR_LED_DATA_OUT (3)
#define PIN_SR_LED_LATCH		(4)
#define PIN_SR_LED_RESET_N	(5)

#define USART_BAUD					(8000000)

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

void mf_led_set_max_brightness(u8 brightness);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */

// LED frame buffer
volatile u16 gFRAME_BUFFER[NUM_PWM_FRAMES][NUM_ENCODERS];

// Frame index (the current frame being transmitted)
volatile u8 mf_frame = 0;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

void hw_led_init(void) {

	// Set all LEDS off
	memset((u16*)gFRAME_BUFFER, (int)0xFFFF, (size_t)sizeof(gFRAME_BUFFER));
	// memset(gFRAME_BUFFER, 0x0000, sizeof(gFRAME_BUFFER));

	// Configure GPIO for LED shift registers
	gpio_dir(&PORT_SR_LED, PIN_SR_LED_ENABLE_N, GPIO_OUTPUT);
	gpio_dir(&PORT_SR_LED, PIN_SR_LED_CLOCK, GPIO_OUTPUT);
	gpio_dir(&PORT_SR_LED, PIN_SR_LED_DATA_OUT, GPIO_OUTPUT);
	gpio_dir(&PORT_SR_LED, PIN_SR_LED_LATCH, GPIO_OUTPUT);
	gpio_dir(&PORT_SR_LED, PIN_SR_LED_RESET_N, GPIO_OUTPUT);

	// Configure USART (SPI) for LED shift registers
	struct usart_config usart_cfg = {
			.baudrate = USART_BAUD,
			.endian		= ENDIAN_LSB,
			.mode			= SPI_MODE_CLK_LO_PHA_LO,
	};

	// Configure DMA to transfer display frames to the USARTs 1-byte tx buffer
	// The configuration will transmit 1 byte at a time, for a total of:
	// 32 bytes (block count) x 1 times (repeat count).
	// The trigger is set to USART data buffer being empty.
	struct dma_channel_cfg dma_cfg = {
			.repeat_count		 = 1,
			.block_size			 = NUM_LED_SHIFT_REGISTERS,
			.burst_len			 = DMA_CH_BURSTLEN_1BYTE_gc,
			.trig_source		 = DMA_CH_TRIGSRC_USARTD0_DRE_gc, // empty usart buffer
			.dbuf_mode			 = DMA_DBUFMODE_DISABLED_gc,
			.int_prio				 = PRIORITY_OFF,
			.err_prio				 = PRIORITY_OFF,
			.src_ptr				 = (uptr)&gFRAME_BUFFER[0][0],
			.src_addr_mode	 = DMA_CH_SRCDIR_INC_gc,
			.src_reload_mode = DMA_CH_SRCRELOAD_NONE_gc,
			.dst_ptr				 = (uptr)&USART_LED.DATA,
			.dst_addr_mode	 = DMA_CH_DESTDIR_FIXED_gc,
			.dst_reload_mode = DMA_CH_DESTRELOAD_NONE_gc,
	};

	// Reset shift registers
	gpio_set(&PORT_SR_LED, PIN_SR_LED_ENABLE_N, 1);
	gpio_set(&PORT_SR_LED, PIN_SR_LED_RESET_N, 0);
	gpio_set(&PORT_SR_LED, PIN_SR_LED_RESET_N, 1);
	gpio_set(&PORT_SR_LED, PIN_SR_LED_ENABLE_N, 0);

	// Configure timer in single slope waveform mode
	TCD0.CTRLB |= TC_WGMODE_SINGLESLOPE_gc;
	TCD0.PER = TIMER_PERIOD; // Timer max tick count (timer resets at this value)
	TCD0.CCA = 0; // Channel A -> Global brightness (0 = max, 255 = min)
	TCD0.CCB = SOFT_PWM_PERIOD; // Channel B -> Software PWM tick (RGB colour
															// generation)

	// Enable timer compare channel A to generate PWM on pin 0 (shift register
	// output enable pin). The duty cycle of this PWM signal determines the
	// maximum brightness of ALL leds
	// TCD0.CTRLB |= TC0_CCAEN_bm;

	// Enable interrupts on compare match for channel B
	TCD0.INTCTRLB |= (PRIORITY_MED << (2)) & TC0_CCBINTLVL_gm;

	dma_channel_init(&DMA.CH0, &dma_cfg);
	usart_module_init(&USART_LED, &usart_cfg);
	TCD0.CTRLA |= TC_CLKSEL_DIV256_gc; // Start the timer!
}

ISR(TCD0_CCB_vect) {
	ATOMIC_BLOCK(ATOMIC_FORCEON) {
		gpio_set(&PORT_SR_LED, PIN_SR_LED_LATCH, 1);
		gpio_set(&PORT_SR_LED, PIN_SR_LED_LATCH, 0);

		uptr ptr = (uptr)&gFRAME_BUFFER[mf_frame][0];

		if (++mf_frame >= NUM_PWM_FRAMES) {
			mf_frame = 0;
		}
		// This ISR needs to trigger every 32 ticks, therefore the
		// compare value must be incremented by 32 ticks each time the interrupt
		// fires. The CCB value must wrap around at the TOP/PER value of the
		// timer.
		TCD0.CCB				 = (TCD0.CCB + SOFT_PWM_PERIOD) % TIMER_PERIOD;
		DMA.CH0.SRCADDR0 = (u8)(ptr >> 0) & 0xFF;
		DMA.CH0.SRCADDR1 = (u8)(ptr >> 8) & 0xFF;
		DMA.CH0.CTRLA |= DMA_CH_ENABLE_bm;
	}
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./console/console.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2025) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "console/console.h"
#include "event/event.h"
#include "event/sys.h"
#include "hal/adc.h" // Add ADC header for temperature reading
#include "hal/signature.h"
#include "hal/sys.h"
#include "led/color.h"	// Add color header for HSV functions
#include "system/rng.h" // Add RNG header for accessing seed value
#include "system/hardware.h"
#include "usb/usb.h"

#include <LUFA/Drivers/USB/Class/Device/CDCClassDevice.h>
#include <avr/pgmspace.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define CONSOLE_PROMPT PSTR("> ")

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#ifdef ENABLE_CONSOLE
// Need the LUFA CDC device info structure
extern USB_ClassInfo_CDC_Device_t lufa_usb_cdc_device;
#endif

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

// Enum defining command identifiers (conceptual, not directly used for indexing
// here)
enum console_command_id {
	CMD_RESET,
	CMD_HELP,
	// Add new command IDs here
	CMD_COUNT // Keep this last for array sizing if needed elsewhere
};

// Function pointer type for command handlers
typedef void (*command_handler_t)(const char* args);

// Structure to define a console command
typedef struct {
	const char* name; // Command name (stored in PROGMEM)
	command_handler_t
							handler;	 // Function pointer to the handler (stored in PROGMEM)
	const char* help_text; // Help text for the command (stored in PROGMEM)
} console_command_t;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

static void process_line(const char* line);

static void handle_reset(const char* args);
static void handle_help(const char* args);
static void handle_config_reset(const char* args);
static void handle_signature(const char* args);
static void handle_temperature(const char* args);
static void handle_rng_seed(const char* args); // New RNG seed command handler
static void handle_set_vmap_hsv(const char* args);

static int console_sys_event_handler(void* event);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */

static char		 line_buffer[CONSOLE_LINE_BUFFER_SIZE];
static uint8_t line_buffer_index = 0;
static bool		 needs_prompt			 = true;

// Command table stored in PROGMEM, initialized using the macro
// Define command strings in PROGMEM
static const char reset_command_name[] PROGMEM = "reset";
static const char reset_command_help[] PROGMEM = "Resets the device";

static const char help_command_name[] PROGMEM = "help";
static const char help_command_help[] PROGMEM = "Shows this help message";

static const char config_reset_command_name[] PROGMEM = "reset_cfg";
static const char config_reset_command_help[] PROGMEM =
		"Performs reset to factory defaults";

static const char signature_command_name[] PROGMEM = "signature";
static const char signature_command_help[] PROGMEM =
		"Displays the production signature row values";

static const char temperature_command_name[] PROGMEM = "temp";
static const char temperature_command_help[] PROGMEM =
		"Reads and displays the internal temperature in Celsius";

static const char rng_seed_command_name[] PROGMEM = "rngseed";
static const char rng_seed_command_help[] PROGMEM =
		"Displays the current random number generator seed value";

// New command definitions for HSV color system
static const char set_vmap_hsv_name[] PROGMEM = "set_vmap_hsv";
static const char set_vmap_hsv_help[] PROGMEM =
		"Sets HSV values for vmap: <bank> <enc> <vmap_idx> <H (0-1535)> <S "
		"(0-255)> <V (0-255)>";

static const console_command_t commands[] PROGMEM = {
		{.name			= help_command_name,
		 .handler		= handle_help,
		 .help_text = help_command_help},
		{.name			= reset_command_name,
		 .handler		= handle_reset,
		 .help_text = reset_command_help},
		{.name			= config_reset_command_name,
		 .handler		= handle_config_reset,
		 .help_text = config_reset_command_help},
		{.name			= signature_command_name,
		 .handler		= handle_signature,
		 .help_text = signature_command_help},
		{.name			= temperature_command_name,
		 .handler		= handle_temperature,
		 .help_text = temperature_command_help},
		{.name			= rng_seed_command_name,
		 .handler		= handle_rng_seed,
		 .help_text = rng_seed_command_help},
		{.name			= set_vmap_hsv_name,
		 .handler		= handle_set_vmap_hsv,
		 .help_text = set_vmap_hsv_help},
};

static const uint8_t num_commands = sizeof(commands) / sizeof(commands[0]);

// Event handler structure for system events
static struct event_ch_handler console_sys_evt_handler_def = {
		.handler	= &console_sys_event_handler,
		.next			= NULL,
		.priority = 1,
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

void console_init(void) {
	line_buffer_index = 0;
	line_buffer[0]		= '\0';
	needs_prompt			= true;
	// Subscribe to system events
	event_channel_subscribe(EVENT_CHANNEL_SYS, &console_sys_evt_handler_def);
}

void console_update(void) {
#ifdef ENABLE_CONSOLE
	if (!usb_cdc_is_active()) {
		needs_prompt = true; // Reset prompt state if disconnected
		return;
	}

	// Print prompt if needed
	if (needs_prompt) {
		console_puts_p(CONSOLE_PROMPT);
		needs_prompt = false;
	}

	int16_t received_byte = CDC_Device_ReceiveByte(&lufa_usb_cdc_device);

	if (received_byte >= 0) {
		char c = (char)received_byte;

		// Handle backspace/delete
		if ((c == '\b' || c == 127) && line_buffer_index > 0) {
			line_buffer_index--;
			line_buffer[line_buffer_index] = '\0';
			// Echo backspace, space, backspace to erase character on terminal
			console_putc('\b');
			console_putc(' ');
			console_putc('\b');
		} else if (c == '\t') { // Handle Tab key for help
			console_putc('\r');
			console_putc('\n');
			handle_help(NULL);				// Call help handler directly
			line_buffer_index = 0;		// Reset buffer
			needs_prompt			= true; // Need a new prompt
		} else if (c == '\r' || c == '\n') {
			// End of line
			console_putc('\r');										 // Echo CR
			console_putc('\n');										 // Echo LF
			line_buffer[line_buffer_index] = '\0'; // Null-terminate
			if (line_buffer_index > 0) {					 // Only process if not empty
				process_line(line_buffer);					 // Use renamed function
			}
			line_buffer_index = 0;		// Reset buffer
			needs_prompt			= true; // Need a new prompt
		} else if (isprint(c) &&
							 line_buffer_index < (CONSOLE_LINE_BUFFER_SIZE - 1)) {
			// Store printable characters
			line_buffer[line_buffer_index++] = c;
			console_putc(c); // Echo character
		}
		// Flush output buffer periodically or after specific actions
		CDC_Device_Flush(&lufa_usb_cdc_device);
	}
#endif // ENABLE_CONSOLE
}

void console_putc(char c) {
#ifdef ENABLE_CONSOLE
	if (usb_cdc_is_active()) {
		CDC_Device_SendByte(&lufa_usb_cdc_device, c);
		// Consider flushing here or let console_update handle it
	}
#endif
}

void console_puts(const char* str) {
#ifdef ENABLE_CONSOLE
	if (usb_cdc_is_active()) {
		CDC_Device_SendString(&lufa_usb_cdc_device, str);
		CDC_Device_Flush(&lufa_usb_cdc_device); // Flush after sending a string
	}
#endif
}

void console_puts_p(const char* str_p) {
#ifdef ENABLE_CONSOLE
	if (usb_cdc_is_active()) {
		CDC_Device_SendString_P(&lufa_usb_cdc_device, str_p);
		CDC_Device_Flush(&lufa_usb_cdc_device); // Flush after sending a string
	}
#endif
}

#include <stdio.h>
#include <stdint.h>

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */

static void process_line(const char* line) {
	char				command_name[CONSOLE_LINE_BUFFER_SIZE];
	const char* args = "";

	// Separate command from arguments
	const char* first_space = strchr(line, ' ');
	if (first_space != NULL) {
		size_t cmd_len = first_space - line;
		if (cmd_len < sizeof(command_name)) {
			strncpy(command_name, line, cmd_len);
			command_name[cmd_len] = '\0';
			args									= first_space + 1;
			while (*args == ' ') { // Skip leading whitespace in args
				args++;
			}
		} else {
			// Command too long, treat as unknown
			strncpy(command_name, line, sizeof(command_name) - 1);
			command_name[sizeof(command_name) - 1] = '\0';
		}
	} else {
		// No space, the whole line is the command
		strncpy(command_name, line, sizeof(command_name) - 1);
		command_name[sizeof(command_name) - 1] = '\0';
	}

	// Iterate through the command table
	for (uint8_t i = 0; i < num_commands; i++) {
		// Read command definition from PROGMEM
		// console_command_t current_command;
		// memcpy_P(&current_command, &commands[i], sizeof(console_command_t));

		// Read command name string directly from PROGMEM into RAM buffer for
		// comparison
		char command_name_pgm[CONSOLE_LINE_BUFFER_SIZE]; // Adjust size if needed
		strncpy_P(command_name_pgm, (const char*)pgm_read_ptr(&commands[i].name),
							sizeof(command_name_pgm) - 1);
		command_name_pgm[sizeof(command_name_pgm) - 1] = '\0';

		// Compare input command with command name from PROGMEM (case-insensitive)
		if (strcasecmp(command_name, command_name_pgm) == 0) {
			// Found a match, read the handler function pointer from PROGMEM
			command_handler_t handler_func =
					(command_handler_t)pgm_read_ptr(&commands[i].handler);

			// Call the handler function pointer if it's not NULL
			if (handler_func != NULL) {
				handler_func(args); // Pass arguments to handler
				return;							// Command processed, exit function
			}
		}
	}

	// Command not found
	console_puts_p(PSTR("Unknown command: "));
	console_puts(line);
	console_puts_p(PSTR("\r\n"));
	handle_help(NULL); // Show help on unknown command
}

// --- Command Handlers ---

static void handle_reset(const char* args __attribute__((unused))) {
	console_puts_p(PSTR("Resetting device...\r\n"));
	// Short delay to allow message to be sent before reset
	for (volatile uint32_t i = 0; i < 50000; ++i) {}
	hal_system_reset(); // This function does not return
}

static void handle_help(const char* args __attribute__((unused))) {
	console_puts_p(PSTR("Available commands:\r\n"));
	char buffer[CONSOLE_LINE_BUFFER_SIZE]; // Buffer for formatting output

	for (uint8_t i = 0; i < num_commands; i++) {
		// Read command name and help text directly from PROGMEM
		char command_name_pgm[20]; // Adjust size as needed
		char help_text_pgm[40];		 // Adjust size as needed
		strncpy_P(command_name_pgm, (const char*)pgm_read_ptr(&commands[i].name),
							sizeof(command_name_pgm) - 1);
		command_name_pgm[sizeof(command_name_pgm) - 1] = '\0';
		strncpy_P(help_text_pgm, (const char*)pgm_read_ptr(&commands[i].help_text),
							sizeof(help_text_pgm) - 1);
		help_text_pgm[sizeof(help_text_pgm) - 1] = '\0';

		// Format and print using snprintf (safer than sprintf)
		snprintf(buffer, sizeof(buffer), "  %-10s - %s\r\n", command_name_pgm,
						 help_text_pgm);
		console_puts(buffer);
	}
}

// New command handler for config reset
static void handle_config_reset(const char* args __attribute__((unused))) {
	console_puts_p(PSTR("Performing factory reset...\r\n"));
	struct sys_event evt = {.type = EVT_SYS_REQ_CFG_RESET, .data = NULL};
	event_post(EVENT_CHANNEL_SYS, &evt);
}

// New command handler for signature row display
static void handle_signature(const char* args __attribute__((unused))) {
	console_puts_p(PSTR("Reading production signature row...\r\n"));
	console_print_signature_row();
}

/**
 * @brief Prints the production signature row values to the console.
 *
 * This function reads all non-reserved fields from the production signature row
 * and prints their names and values to the console.
 */
void console_print_signature_row(void) {
	NVM_PROD_SIGNATURES_t sig_data;
	char									buffer[CONSOLE_LINE_BUFFER_SIZE];

	// Read the entire signature row
	signature_read(&sig_data);

	console_puts_p(PSTR("=== Production Signature Row ===\r\n"));

	// Define all format strings in PROGMEM
	static const char PROGMEM rcosc2m_fmt[]			 = "RCOSC2M:    0x%02X\r\n";
	static const char PROGMEM rcosc2ma_fmt[]		 = "RCOSC2MA:   0x%02X\r\n";
	static const char PROGMEM rcosc32k_fmt[]		 = "RCOSC32K:   0x%02X\r\n";
	static const char PROGMEM rcosc32m_fmt[]		 = "RCOSC32M:   0x%02X\r\n";
	static const char PROGMEM rcosc32ma_fmt[]		 = "RCOSC32MA:  0x%02X\r\n";
	static const char PROGMEM lot_number_fmt[]	 = "%c%c%c%c%c%c\r\n";
	static const char PROGMEM wafer_num_fmt[]		 = "Wafer Num:  %d\r\n";
	static const char PROGMEM coords_fmt[]			 = "Coords:     X=%u, Y=%u\r\n";
	static const char PROGMEM usbcal0_fmt[]			 = "USBCAL0:    0x%02X\r\n";
	static const char PROGMEM usbcal1_fmt[]			 = "USBCAL1:    0x%02X\r\n";
	static const char PROGMEM usbrcosc_fmt[]		 = "USBRCOSC:   0x%02X\r\n";
	static const char PROGMEM usbrcosca_fmt[]		 = "USBRCOSCA:  0x%02X\r\n";
	static const char PROGMEM adcacal0_fmt[]		 = "ADCACAL0:   0x%02X\r\n";
	static const char PROGMEM adcacal1_fmt[]		 = "ADCACAL1:   0x%02X\r\n";
	static const char PROGMEM adcbcal0_fmt[]		 = "ADCBCAL0:   0x%02X\r\n";
	static const char PROGMEM adcbcal1_fmt[]		 = "ADCBCAL1:   0x%02X\r\n";
	static const char PROGMEM tempsense0_fmt[]	 = "TEMPSENSE0:  0x%02X\r\n";
	static const char PROGMEM tempsense1_fmt[]	 = "TEMPSENSE1:  0x%02X\r\n";
	static const char PROGMEM daca0offcal_fmt[]	 = "DACA0OFFCAL:  0x%02X\r\n";
	static const char PROGMEM daca0gaincal_fmt[] = "DACA0GAINCAL: 0x%02X\r\n";
	static const char PROGMEM dacb0offcal_fmt[]	 = "DACB0OFFCAL:  0x%02X\r\n";
	static const char PROGMEM dacb0gaincal_fmt[] = "DACB0GAINCAL: 0x%02X\r\n";
	static const char PROGMEM daca1offcal_fmt[]	 = "DACA1OFFCAL:  0x%02X\r\n";
	static const char PROGMEM daca1gaincal_fmt[] = "DACA1GAINCAL: 0x%02X\r\n";
	static const char PROGMEM dacb1offcal_fmt[]	 = "DACB1OFFCAL:  0x%02X\r\n";
	static const char PROGMEM dacb1gaincal_fmt[] = "DACB1GAINCAL: 0x%02X\r\n";

	// Print oscillator calibration values
	snprintf_P(buffer, sizeof(buffer), rcosc2m_fmt, sig_data.RCOSC2M);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), rcosc2ma_fmt, sig_data.RCOSC2MA);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), rcosc32k_fmt, sig_data.RCOSC32K);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), rcosc32m_fmt, sig_data.RCOSC32M);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), rcosc32ma_fmt, sig_data.RCOSC32MA);
	console_puts(buffer);

	// Print lot number (as ASCII characters)
	console_puts_p(PSTR("Lot Number: "));
	snprintf_P(buffer, sizeof(buffer), lot_number_fmt, sig_data.LOTNUM0,
						 sig_data.LOTNUM1, sig_data.LOTNUM2, sig_data.LOTNUM3,
						 sig_data.LOTNUM4, sig_data.LOTNUM5);
	console_puts(buffer);

	// Print wafer information
	snprintf_P(buffer, sizeof(buffer), wafer_num_fmt, sig_data.WAFNUM);
	console_puts(buffer);

	// Print coordinates
	uint16_t coord_x = (sig_data.COORDX1 << 8) | sig_data.COORDX0;
	uint16_t coord_y = (sig_data.COORDY1 << 8) | sig_data.COORDY0;
	snprintf_P(buffer, sizeof(buffer), coords_fmt, coord_x, coord_y);
	console_puts(buffer);

	// Print USB calibration
	snprintf_P(buffer, sizeof(buffer), usbcal0_fmt, sig_data.USBCAL0);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), usbcal1_fmt, sig_data.USBCAL1);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), usbrcosc_fmt, sig_data.USBRCOSC);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), usbrcosca_fmt, sig_data.USBRCOSCA);
	console_puts(buffer);

	// Print ADC calibration values
	snprintf_P(buffer, sizeof(buffer), adcacal0_fmt, sig_data.ADCACAL0);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), adcacal1_fmt, sig_data.ADCACAL1);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), adcbcal0_fmt, sig_data.ADCBCAL0);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), adcbcal1_fmt, sig_data.ADCBCAL1);
	console_puts(buffer);

	// Print temperature sensor calibration
	snprintf_P(buffer, sizeof(buffer), tempsense0_fmt, sig_data.TEMPSENSE0);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), tempsense1_fmt, sig_data.TEMPSENSE1);
	console_puts(buffer);

	// Print DAC calibration values
	snprintf_P(buffer, sizeof(buffer), daca0offcal_fmt, sig_data.DACA0OFFCAL);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), daca0gaincal_fmt, sig_data.DACA0GAINCAL);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), dacb0offcal_fmt, sig_data.DACB0OFFCAL);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), dacb0gaincal_fmt, sig_data.DACB0GAINCAL);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), daca1offcal_fmt, sig_data.DACA1OFFCAL);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), daca1gaincal_fmt, sig_data.DACA1GAINCAL);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), dacb1offcal_fmt, sig_data.DACB1OFFCAL);
	console_puts(buffer);
	snprintf_P(buffer, sizeof(buffer), dacb1gaincal_fmt, sig_data.DACB1GAINCAL);
	console_puts(buffer);

	console_puts_p(PSTR("==============================\r\n"));
}

// System event handler for console
static int console_sys_event_handler(void* event) {
	assert(event);
	struct sys_event* e = (struct sys_event*)event;

	switch (e->type) {
		case EVT_SYS_RES_CFG_RESET:
			if (e->data.ret != SUCCESS) {
				console_puts_p(PSTR("Configuration reset failed.\r\n"));
			} else {
				console_puts_p(PSTR("Configuration reset.\r\n"));
			}
			needs_prompt = true; // Ensure prompt is reprinted after message
			break;

		default:
			// Ignore other system events
			break;
	}
	return 0; // Indicate event handled (or ignored)
}

/**
 * @brief Command handler for reading and displaying the internal temperature
 *
 * This function initializes the ADC with appropriate settings for temperature
 * reading, reads the internal temperature sensor, and displays the value in
 * degrees Celsius with decimal precision.
 *
 * @param args Command arguments (unused)
 */
static void handle_temperature(const char* args __attribute__((unused))) {
	char buffer[CONSOLE_LINE_BUFFER_SIZE];

	// Initialize ADC for temperature reading with 1V internal reference
	adc_init(ADC_REF_INT1V, ADC_RES_12BIT, ADC_PRESCALER_DIV256);

	// Read temperature from internal sensor with floating point precision
	float temperature = adc_read_temperature_float();

	// Format and display the temperature
	// Convert float to integer parts for printing (e.g., 23.5 -> 23 and 5)
	int16_t temp_int	= (int16_t)temperature;
	int16_t temp_frac = (int16_t)((temperature - temp_int) * 10);
	if (temp_frac < 0)
		temp_frac = -temp_frac; // Ensure fraction is positive

	console_puts_p(PSTR("Reading internal temperature...\r\n"));
	snprintf_P(buffer, sizeof(buffer), PSTR("Temperature: %d.%dC\r\n"), temp_int,
						 temp_frac);
	console_puts(buffer);
}

/**
 * @brief Command handler for displaying the RNG seed value
 *
 * This function retrieves the current random number generator seed value
 * and displays it in hexadecimal format.
 *
 * @param args Command arguments (unused)
 */
static void handle_rng_seed(const char* args __attribute__((unused))) {
	char buffer[CONSOLE_LINE_BUFFER_SIZE];

	// Get the current RNG seed value
	uint32_t seed = rng_get_seed();

	// Display the seed value in both hexadecimal and decimal formats
	console_puts_p(PSTR("Random Number Generator Seed:\r\n"));
	snprintf_P(buffer, sizeof(buffer), PSTR("  0x%08lX (%lu)\r\n"), seed, seed);
	console_puts(buffer);
}

/**
 * @brief Command handler for setting HSV values for vmap
 *
 * This function sets the HSV values for a specified vmap index.
 *
 * @param args Command arguments in the format: <bank> <enc> <vmap_idx> <H
 * (0-1535)> <S (0-255)> <V (0-255)>
 */
static void handle_set_vmap_hsv(const char* args) {
	uint8_t	 bank, enc, vmap_idx;
	uint16_t h;
	uint8_t	 s, v;

	int parsed = sscanf(args, "%hhu %hhu %hhu %hu %hhu %hhu", &bank, &enc,
											&vmap_idx, &h, &s, &v);

	if (parsed != 6) {
		console_puts_p(PSTR("Usage: set_vmap_hsv <bank> <enc> <vmap_idx> <hue "
												"0-1535> <sat 0-255> <val 0-255>\r\n"));
		return;
	}

	// Validate input ranges
	if (bank >= NUM_ENC_BANKS || enc >= NUM_ENCODERS ||
			vmap_idx >= NUM_VMAPS_PER_ENC) {
		console_puts_p(PSTR("Invalid bank, encoder, or vmap index\r\n"));
		return;
	}

	// Set HSV values and update RGB
	color_set_vmap_hsv(bank, enc, vmap_idx, h, s, v);

	console_puts_p(PSTR("HSV color set\r\n"));
}
// filepath: ./system/sys.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <avr/pgmspace.h>
#include "event/event.h"
#include "event/sys.h"
#include "console/console.h"
#include "system/hardware.h"
#include "hal/sys.h" // Include header for sys_reset

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define SYS_EVENT_QUEUE_SIZE 8

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

static int event_handler(void* event);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */

static struct sys_event sys_event_queue[8];

static struct event_ch_handler sys_event_handler = {
		.handler	= &event_handler,
		.next			= NULL,
		.priority = 0,
};

struct event_channel sys_event_ch = {
		.queue			= (u8*)sys_event_queue,
		.queue_size = SYS_EVENT_QUEUE_SIZE,
		.data_size	= sizeof(struct sys_event),
		.handlers		= &sys_event_handler,
		.onehandler = true,
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */

static int event_handler(void* event) {
	assert(event);

	struct sys_event* e = (struct sys_event*)event;
	switch (e->type) {
		case EVT_SYS_REQ_CFG_SAVE: return ERR_NOT_IMPLEMENTED;

		case EVT_SYS_REQ_CFG_RESET: {
			// Post the response event FIRST
			struct sys_event res_evt = {.type			= EVT_SYS_RES_CFG_RESET,
																	.data.ret = true};
			event_post(EVENT_CHANNEL_SYS, &res_evt);

			// Set the reset flag in EEPROM
			mf_cfg_reset();

			// Code should not reach here after reset
			return SUCCESS;
		}

		default: return ERR_BAD_PARAM;
	}

	return 0;
}
// filepath: ./system/systime.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <avr/interrupt.h>

#include "system/time.h"
#include "system/print.h"
#include "hal/timer.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define DIV_ROUND(a, b) (((a) + (b) / 2) / (b))

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */

// static struct timer_config sys_timer = {
// 	.timer = &TCE0,
// 	.periph = TIMER_TCE0,
// 	.channel = TIMER_CHANNEL_A,
// 	.freq = 1000,
// 	.mode = TIMER_MODE_OVF,
// 	.pwm = {0},
// };

static volatile u32 thetime = 0;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

void systime_start(void) {
	TCE0.PER			= DIV_ROUND(F_CPU, 1000);
	TCE0.CTRLB		= TC_WGMODE_NORMAL_gc;
	TCE0.INTCTRLA = TC_OVFINTLVL_LO_gc;
	TCE0.CNT			= 0;
	TCE0.CTRLA		= TC_CLKSEL_DIV1_gc;
}

u32 systime_ms(void) {
	return thetime;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */

ISR(TCE0_OVF_vect) {
	thetime += 1;
}
// filepath: ./system/rng.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2025) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "hal/adc.h"
#include "system/rng.h"
#include "hal/signature.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */

static uint32_t seed = 0; // Seed for the random number generator

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

void rng_init(void) {
	// Read the production signature row
	NVM_PROD_SIGNATURES_t prod_sig;
	signature_read(&prod_sig);

	// Use the wafer coordinates and lot number as the seed
	uint32_t s = (prod_sig.COORDX0 << 24) | (prod_sig.COORDX1 << 16) |
							 (prod_sig.COORDY0 << 8) | (prod_sig.COORDY1);
	s ^= (prod_sig.LOTNUM0 << 24) | (prod_sig.LOTNUM1 << 16) |
			 (prod_sig.LOTNUM2 << 8) | (prod_sig.LOTNUM3);
	s ^= (prod_sig.LOTNUM4 << 24) | (prod_sig.LOTNUM5 << 16);

	// Read the temperature sensor value
	float temperature = adc_read_temperature_float();

	// Combine the temperature with the seed
	s ^= (uint32_t)(temperature * 100); // Scale temperature to an integer

	// Seed the random number generator
	srand(s);

	// Store the seed for later use
	seed = s;
}

uint32_t rng_get_seed(void) {
	return seed;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./main.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "LUFA/Common/Common.h"
#include "LUFA/Drivers/USB/USB.h"
#include "LUFA/Platform/XMEGA/ClockManagement.h"

#include "console/console.h"
#include "event/event.h"
#include "hal/init.h"
#include "led/led.h"
#include "midi/midi.h"
#include "midi/sysex.h"
#include "system/hardware.h"
#include "system/print.h"
#include "system/rng.h"
#include "system/time.h"
#include "usb/usb.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */

struct mf_rt gRT = {
		.curr_bank = 0,
};

struct sys_config gCONFIG = {
		.enc_dead_time			= DEFAULT_ENC_PLAYDEAD_TIME,
		.midi_throttle_time = DEFAULT_MIDI_THROTTLE_TIME,
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

// Entry point
__attribute__((noreturn)) void main(void) {
	avr_xmega128a4u_init(); // Init the AVR xmega peripherals

	rng_init();
	event_init();
	midi_init();
	display_init();
	input_init();
	mf_sysex_init();
	systime_start();
	usb_init();
#ifdef ENABLE_CONSOLE
	console_init();
#endif

	// Enable system interrupts (required for input and led processing)
	sei();

	// Check if the user requested a reset
	uint32_t time	 = systime_ms();
	bool		 reset = false;
	do {
		input_update(); // Need to update input to read button state
		reset = is_reset_pressed();
		if (reset)
			break;
	} while (systime_ms() - time < 200);

	// Initialize config
	cfg_init(reset);

	// Load configuration - either defaults if reset occurred, or existing from
	// EEPROM
	cfg_load();

	hw_led_init();

	println_pmem("Init done");

	while (1) {
		input_update();
		event_update();
		display_update();
		midi_update();
		usb_update();
		cfg_update();
#ifdef ENABLE_CONSOLE
		console_update(); // Update the console module in the main loop
#endif
	}
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./encoder/hardware.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/error.h"
#include "system/types.h"
#include "system/utility.h"
#include "hal/gpio.h"
#include "io/quadrature.h"
#include "io/switch.h"
#include "lfo/lfo.h"

#include "system/hardware.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define PORT_SR_ENC				 (PORTC) // IO port for encoder IO shift registers

#define PIN_SR_ENC_LATCH	 (0) // 74HC595N
#define PIN_SR_ENC_CLOCK	 (1)
#define PIN_SR_ENC_DATA_IN (2)

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

struct quadrature gQUAD_ENC[NUM_ENCODERS];

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */

static struct switch_x16_ctx switch_ctx;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

void hw_encoder_init(void) {
	// Configure GPIO for encoder IO shift regsiters
	gpio_dir(&PORT_SR_ENC, PIN_SR_ENC_LATCH, GPIO_OUTPUT);
	gpio_dir(&PORT_SR_ENC, PIN_SR_ENC_CLOCK, GPIO_OUTPUT);
	gpio_dir(&PORT_SR_ENC, PIN_SR_ENC_DATA_IN, GPIO_INPUT);

	// Latch initial encoder data
	gpio_set(&PORT_SR_ENC, PIN_SR_ENC_LATCH, 0);
	gpio_set(&PORT_SR_ENC, PIN_SR_ENC_LATCH, 1);

	for (uint i = 0; i < NUM_ENCODERS; i++) {
		gQUAD_ENC[i].dir = 0;
		gQUAD_ENC[i].rot = 0;
	}
}

// Scan the hardware state of the midifighter and update local contexts
void hw_encoder_scan(void) {
	// Latch the IO levels into the shift registers
	gpio_set(&PORT_SR_ENC, PIN_SR_ENC_LATCH, 1);

	// Clock the 16 data bits for the encoder switches
	u16 swstates = 0;
	for (size_t i = 0; i < NUM_ENCODER_SWITCHES; i++) {
		gpio_set(&PORT_SR_ENC, PIN_SR_ENC_CLOCK, 0);
		u8 state = !(bool)gpio_get(&PORT_SR_ENC, PIN_SR_ENC_DATA_IN);
		gpio_set(&PORT_SR_ENC, PIN_SR_ENC_CLOCK, 1);
		swstates |= (state << i);
	}

	// Execute the debounce and update routine for the switches
	switch_x16_update(&switch_ctx, swstates);

	// Clock the 32 bits for the 2x16 quadrature encoder signals, and update
	// encoder state.
	for (int i = 0; i < NUM_ENCODERS; ++i) {
		gpio_set(&PORT_SR_ENC, PIN_SR_ENC_CLOCK, 0);
		u8 ch_a = (bool)gpio_get(&PORT_SR_ENC, PIN_SR_ENC_DATA_IN);
		gpio_set(&PORT_SR_ENC, PIN_SR_ENC_CLOCK, 1);
		gpio_set(&PORT_SR_ENC, PIN_SR_ENC_CLOCK, 0);
		u8 ch_b = (bool)gpio_get(&PORT_SR_ENC, PIN_SR_ENC_DATA_IN);
		gpio_set(&PORT_SR_ENC, PIN_SR_ENC_CLOCK, 1);

		quadrature_update(&gQUAD_ENC[i], ch_a, ch_b);
	}

	// Close the door!
	gpio_set(&PORT_SR_ENC, PIN_SR_ENC_LATCH, 0);
}

enum switch_state hw_enc_switch_state(u8 idx) {
	assert(idx < NUM_ENCODER_SWITCHES);

	if (switchx16_was_pressed(&switch_ctx, idx)) {
		return SWITCH_PRESSED;
	}

	if (switchx16_was_released(&switch_ctx, idx)) {
		return SWITCH_RELEASED;
	}

	return SWITCH_IDLE;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./encoder/quadrature.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"
#include "event/io.h"

#include "io/quadrature.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum quad_state {
	QUAD_START,
	QUAD_CCW,
	QUAD_CW,
	QUAD_MIDDLE,
	QUAD_MID_CW,
	QUAD_MID_CCW,

	QUAD_NB,
};

enum encoder_dir {
	DIR_ST	= 0x00, // Stationary
	DIR_CW	= 0x10, // Clockwise
	DIR_CCW = 0x20, // Counter-clockwise
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
 * Rotory decoder based on
 * https://github.com/buxtronix/arduino/tree/master/libraries/Rotary
 * Copyright 2011 Ben Buxton.
 * Licenced under the GNU GPL Version 3.
 * Contact: bb@cactii.net
 */
static const enum quad_state quad_states[QUAD_NB][4] = {
		// Current Quadrature GrayCode
		{QUAD_MIDDLE, QUAD_CW, QUAD_CCW, QUAD_START},
		{QUAD_MIDDLE | DIR_CCW, QUAD_START, QUAD_CCW, QUAD_START},
		{QUAD_MIDDLE | DIR_CW, QUAD_CW, QUAD_START, QUAD_START},
		{QUAD_MIDDLE, QUAD_MID_CCW, QUAD_MID_CW, QUAD_START},
		{QUAD_MIDDLE, QUAD_MIDDLE, QUAD_MID_CW, QUAD_START | DIR_CW},
		{QUAD_MIDDLE, QUAD_MID_CCW, QUAD_MIDDLE, QUAD_START | DIR_CCW},
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

void quadrature_update(struct quadrature* ctx, uint ch_a, uint ch_b) {
	assert(ctx);

	uint val = (ch_b << 1) | ch_a;
	ctx->rot = quad_states[ctx->rot & 0x0F][val];
	ctx->dir = ctx->rot & 0x30;
}

inline int quadrature_direction(struct quadrature* ctx) {
	assert(ctx);

	if (ctx->dir == DIR_CW) {
		return 1;
	} else if (ctx->dir == DIR_CCW) {
		return -1;
	}

	return 0;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./encoder/encoder.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#include <stdio.h>
#include "console/console.h"
#include "io/encoder.h"
#include "event/event.h"
#include "event/io.h"
#include "system/time.h" // Include for systime_ms
#include <stdint.h>
#include <assert.h> // Include for assert

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define THR_VERY_SLOW		 150
#define THR_SLOW				 75
#define THR_MEDIUM			 30
#define THR_FAST				 10

// Corresponding acceleration factors - Higher value = more acceleration
#define FACTOR_BASE			 1
#define FACTOR_SLOW			 2
#define FACTOR_MEDIUM		 3
#define FACTOR_FAST			 5
#define FACTOR_VERY_FAST 7 // Factor when t < THR_FAST

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

int encoder_movement_init(struct encoder_movement* enc) {
	assert(enc);
	enc->velocity		= 0;
	enc->direction	= 0;
	enc->accel_mode = 0;

	// Initialize time-based acceleration state
	enc->last_update_time = systime_ms();
	enc->accel_factor			= 1;

	return 0;
}

bool encoder_movement_update(struct encoder_movement* enc, int new_direction) {
	assert(enc);

	u32 current_time = systime_ms();

	// If encoder stopped
	if (new_direction == 0) {
		enc->velocity			= 0;
		enc->direction		= 0;
		enc->accel_factor = 1;
		return false; // No change
	}

	u32 time_delta				= current_time - enc->last_update_time;
	enc->last_update_time = current_time;

	// Determine the base acceleration factor based on time delta
	u16 current_accel_factor = 1; // Default factor

	if (time_delta == 0) {
		// Assign max acceleration if delta is zero (very fast)
		current_accel_factor = FACTOR_VERY_FAST;
	} else if (time_delta < THR_FAST) { // < 10ms
		current_accel_factor = FACTOR_VERY_FAST;
	} else if (time_delta < THR_MEDIUM) { // 10ms to 29ms
		current_accel_factor = FACTOR_FAST;
	} else if (time_delta < THR_SLOW) { // 30ms to 74ms
		current_accel_factor = FACTOR_MEDIUM;
	} else if (time_delta < THR_VERY_SLOW) { // 75ms to 149ms
		current_accel_factor = FACTOR_SLOW;
	} else { // >= 150ms
		current_accel_factor = FACTOR_BASE;
	}

	// Handle direction changes - Optional: Reset to base speed on change?
	if (new_direction != enc->direction) {
		enc->direction = (i8)new_direction;
		// Option: uncomment below to force slow speed on direction change
		// current_accel_factor = FACTOR_BASE;
	}

	// Store the decided factor
	enc->accel_factor = current_accel_factor;

	// Calculate velocity based on direction and the current acceleration factor
	i16 base_velocity = enc->direction; // +1 or -1
	enc->velocity			= base_velocity * enc->accel_factor;

	// Apply velocity bounds
	const i16 ENC_MAX_VELOCITY =
			50; // Example max overall velocity change per update (adjust as needed)
	if (enc->velocity > ENC_MAX_VELOCITY) {
		enc->velocity = ENC_MAX_VELOCITY;
	} else if (enc->velocity < -ENC_MAX_VELOCITY) {
		enc->velocity = -ENC_MAX_VELOCITY;
	}

	// // Debug output
	// static char buffer[40];
	// snprintf(buffer, sizeof(buffer), "v:%d f:%u t:%lu d:%d\r\n", enc->velocity,
	// 				 enc->accel_factor, time_delta, enc->direction);
	// console_puts(buffer);
	return true; // Encoder moved
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./usb/usb_lufa.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <avr/pgmspace.h>

#include "system/types.h"
#include "usb/usb.h"
#include "usb/usb_lufa.h"
#include "system/print.h"

#include "LUFA/Common/Common.h"
#include "LUFA/Drivers/USB/USB.h"
#include "LUFA/Drivers/USB/Class/Common/MIDIClassCommon.h"
#include "LUFA/Drivers/USB/Class/Device/MIDIClassDevice.h"
#include "LUFA/Drivers/USB/Class/Device/CDCClassDevice.h" // Add CDC include
#include "LUFAConfig.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define USB_VENDOR_ID								0x2580
#define USB_PRODUCT_ID							0x0007
#define USB_HID_EPSIZE							32
#define USB_KEYBOARD_EPSIZE					8
#define USB_MOUSE_EPSIZE						8
#define USB_USB_MIDI_STREAM_EPSIZE	64
#define USB_CDC_NOTIFICATION_EPSIZE 8
#define USB_CDC_EPSIZE							16
#define USB_MIDI_POLLING_INTERVAL		0x05

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

extern USB_ClassInfo_MIDI_Device_t lufa_usb_midi_device;
#ifdef ENABLE_CONSOLE
extern USB_ClassInfo_CDC_Device_t lufa_usb_cdc_device;
#endif

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum usb_desc_str {
	DESC_STR_LANG = 0,
	DESC_STR_MF		= 1,
	DESC_STR_PROD = 2,
	DESC_STR_SER	= 3,

	DESC_STR_NB,
};

struct usb_descriptor {
	USB_Descriptor_Configuration_Header_t Config;

	USB_Descriptor_Interface_Association_t Audio_Interface_Association;
	// MIDI Audio Control Interface
	USB_Descriptor_Interface_t						 Audio_ControlInterface;
	USB_Audio_Descriptor_Interface_AC_t		 Audio_ControlInterface_SPC;

	// MIDI Audio Streaming Interface
	USB_Descriptor_Interface_t								Audio_StreamInterface;
	USB_MIDI_Descriptor_AudioInterface_AS_t		Audio_StreamInterface_SPC;
	USB_MIDI_Descriptor_InputJack_t						MIDI_In_Jack_Emb;
	USB_MIDI_Descriptor_InputJack_t						MIDI_In_Jack_Ext;
	USB_MIDI_Descriptor_OutputJack_t					MIDI_Out_Jack_Emb;
	USB_MIDI_Descriptor_OutputJack_t					MIDI_Out_Jack_Ext;
	USB_Audio_Descriptor_StreamEndpoint_Std_t MIDI_In_Jack_Endpoint;
	USB_MIDI_Descriptor_Jack_Endpoint_t				MIDI_In_Jack_Endpoint_SPC;
	USB_Audio_Descriptor_StreamEndpoint_Std_t MIDI_Out_Jack_Endpoint;
	USB_MIDI_Descriptor_Jack_Endpoint_t				MIDI_Out_Jack_Endpoint_SPC;

#ifdef HID_ENABLE
	// Keyboard/Mouse
	USB_Descriptor_Interface_t HID_Interface;
	USB_HID_Descriptor_HID_t	 HID_Descriptor;
	USB_Descriptor_Endpoint_t	 HID_In_Endpoint;
#endif

#ifdef ENABLE_CONSOLE
	// Virtual Serial
	// CDC Control Interface
	USB_Descriptor_Interface_Association_t CDC_Interface_Association;
	USB_Descriptor_Interface_t						 CDC_CCI_Interface;
	USB_CDC_Descriptor_FunctionalHeader_t	 CDC_Functional_Header;
	USB_CDC_Descriptor_FunctionalACM_t		 CDC_Functional_ACM;
	USB_CDC_Descriptor_FunctionalUnion_t	 CDC_Functional_Union;
	USB_Descriptor_Endpoint_t							 CDC_NotificationEndpoint;
	// CDC Data Interface
	USB_Descriptor_Interface_t						 CDC_DCI_Interface;
	USB_Descriptor_Endpoint_t							 CDC_DataOutEndpoint;
	USB_Descriptor_Endpoint_t							 CDC_DataInEndpoint;
#endif
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */

#pragma GCC diagnostic ignored "-Wpedantic"

PROGMEM static const USB_Descriptor_String_t desc_str_lang =
		USB_STRING_DESCRIPTOR_ARRAY(LANGUAGE_ID_ENG);

PROGMEM static const USB_Descriptor_String_t desc_str_mf =
		USB_STRING_DESCRIPTOR(L"NEON");

PROGMEM static const USB_Descriptor_String_t desc_str_prod =
		USB_STRING_DESCRIPTOR(L"SAMURAI");

PROGMEM static const USB_Descriptor_String_t desc_str_ser =
		USB_STRING_DESCRIPTOR(L"2024");

#pragma GCC diagnostic pop

#ifdef ENABLE_CONSOLE
USB_ClassInfo_CDC_Device_t lufa_usb_cdc_device = {
		.Config =
				{
						.ControlInterfaceNumber = 0,
						.DataINEndpoint =
								{
										.Address = (CDC_IN_EPNUM | ENDPOINT_DIR_IN),
										.Size		 = USB_CDC_EPSIZE,
										.Banks	 = 1,
								},
						.DataOUTEndpoint =
								{
										.Address = (CDC_OUT_EPNUM | ENDPOINT_DIR_OUT),
										.Size		 = USB_CDC_EPSIZE,
										.Banks	 = 1,
								},
						.NotificationEndpoint =
								{
										.Address = (CDC_NOTIFICATION_EPNUM | ENDPOINT_DIR_IN),
										.Size		 = USB_CDC_NOTIFICATION_EPSIZE,
										.Banks	 = 1,
								},
				},
};
#endif

PROGMEM static const USB_Descriptor_Device_t desc_device = {
		.Header = {.Size = sizeof(USB_Descriptor_Device_t), .Type = DTYPE_Device},
		.USBSpecification = VERSION_BCD(1, 1, 0),

#ifdef ENABLE_CONSOLE
		.Class		= USB_CSCP_IADDeviceClass,
		.SubClass = USB_CSCP_IADDeviceSubclass,
		.Protocol = USB_CSCP_IADDeviceProtocol,
#else
		.Class		= USB_CSCP_NoDeviceClass,
		.SubClass = USB_CSCP_NoDeviceSubclass,
		.Protocol = USB_CSCP_NoDeviceProtocol,
#endif

		.Endpoint0Size				= FIXED_CONTROL_ENDPOINT_SIZE,
		.VendorID							= USB_VENDOR_ID,
		.ProductID						= USB_PRODUCT_ID,
		.ReleaseNumber				= VERSION_BCD(0, 0, 1),
		.ManufacturerStrIndex = DESC_STR_MF,
		.ProductStrIndex			= DESC_STR_PROD,
		// .SerialNumStrIndex		= DESC_STR_SER,
		.SerialNumStrIndex		= USE_INTERNAL_SERIAL,

		.NumberOfConfigurations = FIXED_NUM_CONFIGURATIONS,
};

PROGMEM static const struct usb_descriptor desc_cfg = {
		.Config =
				{
						.Header =
								{
										.Size = sizeof(USB_Descriptor_Configuration_Header_t),
										.Type = DTYPE_Configuration,
								},
						.TotalConfigurationSize = sizeof(struct usb_descriptor),
						.TotalInterfaces				= NUM_USB_INTERFACES,
						.ConfigurationNumber		= 1,
						.ConfigurationStrIndex	= NO_DESCRIPTOR,
						.ConfigAttributes				= (USB_CONFIG_ATTR_RESERVED),
						.MaxPowerConsumption		= USB_CONFIG_POWER_MA(480),
				},

		.Audio_Interface_Association =
				{
						.Header =
								{
										.Size = sizeof(USB_Descriptor_Interface_Association_t),
										.Type = DTYPE_InterfaceAssociation,
								},
						.FirstInterfaceIndex = MIDI_AC_INTERFACE,
						.TotalInterfaces		 = 2,
						.Class							 = AUDIO_CSCP_AudioClass,
						.SubClass						 = AUDIO_CSCP_ControlSubclass,
						.Protocol						 = AUDIO_CSCP_ControlProtocol,
						.IADStrIndex				 = NO_DESCRIPTOR,
				},
		.Audio_ControlInterface =
				{
						.Header =
								{
										.Size = sizeof(USB_Descriptor_Interface_t),
										.Type = DTYPE_Interface,
								},
						.InterfaceNumber	 = MIDI_AC_INTERFACE,
						.AlternateSetting	 = 0,
						.TotalEndpoints		 = 0,
						.Class						 = AUDIO_CSCP_AudioClass,
						.SubClass					 = AUDIO_CSCP_ControlSubclass,
						.Protocol					 = AUDIO_CSCP_ControlProtocol,
						.InterfaceStrIndex = NO_DESCRIPTOR,
				},
		.Audio_ControlInterface_SPC =
				{
						.Header =
								{
										.Size = sizeof(USB_Audio_Descriptor_Interface_AC_t),
										.Type = AUDIO_DTYPE_CSInterface,
								},
						.Subtype				 = AUDIO_DSUBTYPE_CSInterface_Header,
						.ACSpecification = VERSION_BCD(1, 0, 0),
						.TotalLength		 = sizeof(USB_Audio_Descriptor_Interface_AC_t),
						.InCollection		 = 1,
						.InterfaceNumber = MIDI_AS_INTERFACE,
				},
		.Audio_StreamInterface =
				{
						.Header =
								{
										.Size = sizeof(USB_Descriptor_Interface_t),
										.Type = DTYPE_Interface,
								},
						.InterfaceNumber	 = MIDI_AS_INTERFACE,
						.AlternateSetting	 = 0,
						.TotalEndpoints		 = 2,
						.Class						 = AUDIO_CSCP_AudioClass,
						.SubClass					 = AUDIO_CSCP_MIDIStreamingSubclass,
						.Protocol					 = AUDIO_CSCP_StreamingProtocol,
						.InterfaceStrIndex = NO_DESCRIPTOR,
				},
		.Audio_StreamInterface_SPC =
				{
						.Header =
								{
										.Size = sizeof(USB_MIDI_Descriptor_AudioInterface_AS_t),
										.Type = AUDIO_DTYPE_CSInterface,
								},
						.Subtype						= AUDIO_DSUBTYPE_CSInterface_General,
						.AudioSpecification = VERSION_BCD(1, 0, 0),
						.TotalLength =
								offsetof(struct usb_descriptor, MIDI_Out_Jack_Endpoint_SPC) +
								sizeof(USB_MIDI_Descriptor_Jack_Endpoint_t) -
								offsetof(struct usb_descriptor, Audio_StreamInterface_SPC),
				},
		.MIDI_In_Jack_Emb =
				{
						.Header =
								{
										.Size = sizeof(USB_MIDI_Descriptor_InputJack_t),
										.Type = AUDIO_DTYPE_CSInterface,
								},
						.Subtype			= AUDIO_DSUBTYPE_CSInterface_InputTerminal,
						.JackType			= MIDI_JACKTYPE_Embedded,
						.JackID				= 0x01,
						.JackStrIndex = NO_DESCRIPTOR,
				},
		.MIDI_In_Jack_Ext =
				{
						.Header				= {.Size = sizeof(USB_MIDI_Descriptor_InputJack_t),
														 .Type = AUDIO_DTYPE_CSInterface},
						.Subtype			= AUDIO_DSUBTYPE_CSInterface_InputTerminal,
						.JackType			= MIDI_JACKTYPE_External,
						.JackID				= 0x02,
						.JackStrIndex = NO_DESCRIPTOR,
				},
		.MIDI_Out_Jack_Emb =
				{
						.Header =
								{
										.Size = sizeof(USB_MIDI_Descriptor_OutputJack_t),
										.Type = AUDIO_DTYPE_CSInterface,
								},
						.Subtype			= AUDIO_DSUBTYPE_CSInterface_OutputTerminal,
						.JackType			= MIDI_JACKTYPE_Embedded,
						.JackID				= 0x03,
						.NumberOfPins = 1,
						.SourceJackID = {0x02},
						.SourcePinID	= {0x01},
						.JackStrIndex = NO_DESCRIPTOR,
				},
		.MIDI_Out_Jack_Ext =
				{
						.Header =
								{
										.Size = sizeof(USB_MIDI_Descriptor_OutputJack_t),
										.Type = AUDIO_DTYPE_CSInterface,
								},
						.Subtype			= AUDIO_DSUBTYPE_CSInterface_OutputTerminal,
						.JackType			= MIDI_JACKTYPE_External,
						.JackID				= 0x04,
						.NumberOfPins = 1,
						.SourceJackID = {0x01},
						.SourcePinID	= {0x01},
						.JackStrIndex = NO_DESCRIPTOR,
				},
		.MIDI_In_Jack_Endpoint =
				{
						.Endpoint =
								{
										.Header =
												{
														.Size = sizeof(
																USB_Audio_Descriptor_StreamEndpoint_Std_t),
														.Type = DTYPE_Endpoint,
												},
										.EndpointAddress =
												(ENDPOINT_DIR_OUT | USB_EP_MIDI_STREAM_OUT),
										.Attributes				 = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC |
																		ENDPOINT_USAGE_DATA),
										.EndpointSize			 = USB_MIDI_STREAM_EPSIZE,
										.PollingIntervalMS = USB_MIDI_POLLING_INTERVAL,
								},
						.Refresh						= 0,
						.SyncEndpointNumber = 0,
				},
		.MIDI_In_Jack_Endpoint_SPC =
				{
						.Header =
								{
										.Size = sizeof(USB_MIDI_Descriptor_Jack_Endpoint_t),
										.Type = AUDIO_DTYPE_CSEndpoint,
								},
						.Subtype						= AUDIO_DSUBTYPE_CSEndpoint_General,
						.TotalEmbeddedJacks = 0x01,
						.AssociatedJackID		= {0x01},
				},
		.MIDI_Out_Jack_Endpoint =
				{
						.Endpoint =
								{
										.Header =
												{
														.Size = sizeof(
																USB_Audio_Descriptor_StreamEndpoint_Std_t),
														.Type = DTYPE_Endpoint,
												},
										.EndpointAddress =
												(ENDPOINT_DIR_IN | USB_EP_MIDI_STREAM_IN),
										.Attributes				 = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC |
																		ENDPOINT_USAGE_DATA),
										.EndpointSize			 = USB_MIDI_STREAM_EPSIZE,
										.PollingIntervalMS = USB_MIDI_POLLING_INTERVAL,
								},
						.Refresh						= 0,
						.SyncEndpointNumber = 0,
				},
		.MIDI_Out_Jack_Endpoint_SPC =
				{
						.Header =
								{
										.Size = sizeof(USB_MIDI_Descriptor_Jack_Endpoint_t),
										.Type = AUDIO_DTYPE_CSEndpoint,
								},
						.Subtype						= AUDIO_DSUBTYPE_CSEndpoint_General,
						.TotalEmbeddedJacks = 0x01,
						.AssociatedJackID		= {0x03},
				},

#ifdef HID_ENABLE
#error "No descriptor configuration yet - woops!"
#endif

#ifdef ENABLE_CONSOLE
		.CDC_Interface_Association =
				{
						.Header = {.Size = sizeof(USB_Descriptor_Interface_Association_t),
											 .Type = DTYPE_InterfaceAssociation},
						.FirstInterfaceIndex = CCI_INTERFACE,
						.TotalInterfaces		 = 2,
						.Class							 = CDC_CSCP_CDCClass,
						.SubClass						 = CDC_CSCP_ACMSubclass,
						.Protocol						 = CDC_CSCP_ATCommandProtocol,
						.IADStrIndex				 = NO_DESCRIPTOR,
				},
		.CDC_CCI_Interface = {.Header = {.Size = sizeof(USB_Descriptor_Interface_t),
																		 .Type = DTYPE_Interface},
													.InterfaceNumber	 = CCI_INTERFACE,
													.AlternateSetting	 = 0,
													.TotalEndpoints		 = 1,
													.Class						 = CDC_CSCP_CDCClass,
													.SubClass					 = CDC_CSCP_ACMSubclass,
													.Protocol					 = CDC_CSCP_ATCommandProtocol,
													.InterfaceStrIndex = NO_DESCRIPTOR},
		.CDC_Functional_Header =
				{
						.Header	 = {.Size = sizeof(USB_CDC_Descriptor_FunctionalHeader_t),
												.Type = CDC_DTYPE_CSInterface},
						.Subtype = 0x00,
						.CDCSpecification = VERSION_BCD(1, 1, 0),
				},
		.CDC_Functional_ACM =
				{
						.Header				= {.Size = sizeof(USB_CDC_Descriptor_FunctionalACM_t),
														 .Type = CDC_DTYPE_CSInterface},
						// .Subtype                = 0x02,
						// .Capabilities           = 0x02,
						.Capabilities = 0x06,
				},
		.CDC_Functional_Union =
				{
						.Header	 = {.Size = sizeof(USB_CDC_Descriptor_FunctionalUnion_t),
												.Type = CDC_DTYPE_CSInterface},
						.Subtype = 0x06,
						.MasterInterfaceNumber = CCI_INTERFACE,
						.SlaveInterfaceNumber	 = CDI_INTERFACE,
				},
		.CDC_NotificationEndpoint =
				{.Header					= {.Size = sizeof(USB_Descriptor_Endpoint_t),
														 .Type = DTYPE_Endpoint},
				 .EndpointAddress = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM),
				 .Attributes =
						 (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
				 .EndpointSize			= USB_CDC_NOTIFICATION_EPSIZE,
				 .PollingIntervalMS = 0xFF},
		.CDC_DCI_Interface = {.Header = {.Size = sizeof(USB_Descriptor_Interface_t),
																		 .Type = DTYPE_Interface},
													.InterfaceNumber	 = CDI_INTERFACE,
													.AlternateSetting	 = 0,
													.TotalEndpoints		 = 2,
													.Class						 = CDC_CSCP_CDCDataClass,
													.SubClass					 = CDC_CSCP_NoDataSubclass,
													.Protocol					 = CDC_CSCP_NoDataProtocol,
													.InterfaceStrIndex = NO_DESCRIPTOR},
		.CDC_DataOutEndpoint =
				{.Header					= {.Size = sizeof(USB_Descriptor_Endpoint_t),
														 .Type = DTYPE_Endpoint},
				 .EndpointAddress = (ENDPOINT_DIR_OUT | CDC_OUT_EPNUM),
				 .Attributes =
						 (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
				 .EndpointSize			= USB_CDC_EPSIZE,
				 .PollingIntervalMS = 0x05},
		.CDC_DataInEndpoint = {.Header = {.Size = sizeof(USB_Descriptor_Endpoint_t),
																			.Type = DTYPE_Endpoint},
													 .EndpointAddress = (ENDPOINT_DIR_IN | CDC_IN_EPNUM),
													 .Attributes = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC |
																					ENDPOINT_USAGE_DATA),
													 .EndpointSize			= USB_CDC_EPSIZE,
													 .PollingIntervalMS = 0x05},
#endif
};

#pragma GCC diagnostic ignored "-Wunused-variable"
static bool vser_active = false;
#pragma GCC diagnostic pop

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

int usb_init(void) {
	USB_Init(); // Init LUFA usb stack
	return 0;
}

int usb_update(void) {
	// The USB packets are periodically transmitted by LUFA, calling the
	// MIDI_Device_USBTask function flushes the packets immediately to the
	// host.)
	MIDI_Device_USBTask(&lufa_usb_midi_device);

#ifdef ENABLE_CONSOLE
	// Throw away unused received bytes from host
	if (vser_active) {
		// while (CDC_Device_ReceiveByte(&lufa_usb_cdc_device) == true) {}
		CDC_Device_USBTask(&lufa_usb_cdc_device);
	}

#endif

	USB_USBTask(); // LUFA usb stack update
	return 0;
}

/** This function is called by the library when in device mode, and must be
 * overridden (see library "USB Descriptors" documentation) by the application
 * code so that the address and size of a requested descriptor can be given to
 * the USB library. When the device receives a Get Descriptor request on the
 * control endpoint, this function is called so that the descriptor details can
 * be passed back and the appropriate descriptor sent back to the USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t		 wValue,
																		const uint16_t		 wIndex,
																		const void** const DescriptorAddress) {
	const uint8_t DescriptorType	= (u8)(wValue >> 8);
	const uint8_t DescriptorIndex = (wValue & 0xFF);
	const void*		Address					= NULL;
	uint16_t			Size						= NO_DESCRIPTOR;

	switch (DescriptorType) {
		case DTYPE_Device:
			Address = &desc_device;
			Size		= sizeof(USB_Descriptor_Device_t);
			break;

		case DTYPE_Configuration:
			Address = &desc_cfg;
			Size		= sizeof(struct usb_descriptor);
			break;

		case DTYPE_String:
			switch (DescriptorIndex) {
				case DESC_STR_LANG:
					Address = &desc_str_lang;
					Size		= pgm_read_byte(&desc_str_lang.Header.Size);
					break;

				case DESC_STR_MF:
					Address = &desc_str_mf;
					Size		= pgm_read_byte(&desc_str_mf.Header.Size);

					break;

				case DESC_STR_PROD:
					Address = &desc_str_prod;
					Size		= pgm_read_byte(&desc_str_prod.Header.Size);
					break;

				case DESC_STR_SER:
					Address = &desc_str_ser;
					Size		= pgm_read_byte(&desc_str_ser.Header.Size);
					break;
			}

			break;
		case HID_DTYPE_HID:
			switch (wIndex) {

#ifdef HID_ENABLE
#error "This is not completed"
				case HID_INTERFACE:
					Address = &ConfigurationDescriptor.Shared_HID;
					Size		= sizeof(USB_HID_Descriptor_HID_t);

					break;
#endif
			}

			break;
		case HID_DTYPE_Report:
			switch (wIndex) {
#ifdef HID_ENABLE
#error "This is not completed"
				case HID_INTERFACE:
					Address = &SharedReport;
					Size		= sizeof(SharedReport);

					break;
#endif
			}

			break;
	}

	*DescriptorAddress = Address;
	return Size;
}

// Callback for USB device connection
void EVENT_USB_Device_Connect(void) {
}

// Callback for USB device disconnection
void EVENT_USB_Device_Disconnect(void) {
}

// Callback for USB device configuration changed
void EVENT_USB_Device_ConfigurationChanged(void) {
	MIDI_Device_ConfigureEndpoints(&lufa_usb_midi_device);

#ifdef HID_ENABLE
	ConfigSuccess &= Endpoint_ConfigureEndpoint(
			(SHARED_IN_EPNUM | ENDPOINT_DIR_IN), EP_TYPE_INTERRUPT, SHARED_EPSIZE, 1);
#endif

#ifdef ENABLE_CONSOLE
	CDC_Device_ConfigureEndpoints(&lufa_usb_cdc_device);
#endif
}

void EVENT_USB_Device_ControlRequest(void) {
	MIDI_Device_ProcessControlRequest(&lufa_usb_midi_device);

#ifdef HID_ENABLE
#error "Need to handle HID class requests here"
#endif

#ifdef ENABLE_CONSOLE
	CDC_Device_ProcessControlRequest(&lufa_usb_cdc_device);
#endif
}

#ifdef ENABLE_CONSOLE
void EVENT_CDC_Device_ControLineStateChanged(
		USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo) {
	/* You can get changes to the virtual CDC lines in this callback; a common
		 use-case is to use the Data Terminal Ready (DTR) flag to enable and
		 disable CDC communications in your application when set to avoid the
		 application blocking while waiting for a host to become ready and read
		 in the pending data from the USB endpoints.
	*/
	vser_active = (CDCInterfaceInfo->State.ControlLineStates.HostToDevice &
								 CDC_CONTROL_LINE_OUT_DTR) != 0;
}

// Function to check if the virtual serial port is active (DTR asserted)
bool usb_cdc_is_active(void) {
	return vser_active;
}

void println_progmem(const char* const str) {
	assert(str);

	if (vser_active) {
		CDC_Device_SendString_P(&lufa_usb_cdc_device, str);
		CDC_Device_SendString_P(&lufa_usb_cdc_device, PSTR("\r\n"));
		CDC_Device_Flush(&lufa_usb_cdc_device);
	}
}

void println(const char* const str) {
	assert(str);

	if (vser_active) {
		CDC_Device_SendString(&lufa_usb_cdc_device, str);
		CDC_Device_SendString_P(&lufa_usb_cdc_device, PSTR("\r\n"));
		CDC_Device_Flush(&lufa_usb_cdc_device);
	}
}

void printbuf(u8* buf, uint len) {
	assert(buf);

	if (vser_active) {
		CDC_Device_SendData(&lufa_usb_cdc_device, buf, len);
		CDC_Device_SendString_P(&lufa_usb_cdc_device, PSTR("\r\n"));
		CDC_Device_Flush(&lufa_usb_cdc_device);
	}
}

#endif

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/menu/menu.h
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
enum menu_action {
	MENU_ACTION_PARENT,
	MENU_ACTION_PREVIOUS,
	MENU_ACTION_NEXT,
	MENU_ACTION_EXIT,
	MENU_ACTION_SAVE,

	MENU_ACTION_NB
};

typedef void(transition_f)(void* ctx);
typedef void(display_f)(void* ctx);

struct menu_page {
	struct struct menu_page* parent;
	struct struct menu_page* child;
	display_f*							 update_display;
	transition_f*						 on_enter;
	transition_f*						 on_next;
	transition_f*						 on_prev;
};

struct menu {
	struct struct menu_page* entry;
	transition_f*						 on_start;
	transition_f*						 on_exit;
	transition_f*						 on_save;
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

int menu_start(struct menu* menu);
int menu_stop(void);
int menu_update(struct menu_page* page);
int menu_process_action(enum menu_action action);
// filepath: ./include/lfo/lfo.h
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum waveform {
	WAVEFORM_SINE,
	WAVEFORM_SAW,
	WAVEFORM_SQUARE,

	WAVEFORM_NB,
};

struct lfo {
	i16						frequency;
	i16						amplitude;
	i16						phase;
	i16						sampleRate;
	enum waveform waveform;
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

i16 lfo_update(struct lfo* lfo);
// filepath: ./include/io/quadrature.h
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

struct quadrature {
	u8 dir; // Current direction
	u8 rot; // Rotational state
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief Processes the input from a quadrature encoder and returns
 * a direction.
 *
 * @param ctx Pointer to quadrature context.
 * @param ch_a Current value of channel A.
 * @param ch_b Current value of channel B.
 */
void quadrature_update(struct quadrature* ctx, uint ch_a, uint ch_b);

/**
 * @brief Get the last known direction of a quadrature encoder.
 *
 * @param ctx Pointer to quadrature context.
 * @return int 0 = stationary, 1 = CW, -1 = CCW.
 */
int quadrature_direction(struct quadrature* ctx);
// filepath: ./include/io/switch.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*
	There are two sets of structs and functions for switches, switch_x8_xxx and
	switch_x16_xxx. x8 is for a set of 8 switches, x16 is for a set of 16
	switches. If you need to handle 32 switches then use two sets of x16. If you
	need to handle < 8 switches then just use the x8. Each unique set of
	 switches needs its own unique context struct. For general use:

			1. Poll the state of your switches and then add them to a bitfield.
	 Then call the switch_xN_update() function and pass in the bitfield.

			2. Call the debounce function once before you attempt to read the
	 state of the switches.

			3. Call the switch_xN_state functions to get the state of the
	 switch(es).


	Note - The debounce should not be called every time you poll, that is a
	 waste of cpu time.
*/
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define SWITCH_DEBOUNCE_SAMPLES (100)

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum switch_state {
	SWITCH_IDLE,
	SWITCH_RELEASED,
	SWITCH_PRESSED,
};

struct switch_x8_ctx {
	u8 buf[SWITCH_DEBOUNCE_SAMPLES]; // debounce buffer (private)
	u8 index;												 // current buffer index
	u8 current;											 // states bitfield (private)
	u8 previous;										 // states bitfield (private)
	u8 raw;													 // switch states bitfield (private)
};

struct switch_x16_ctx {
	u16 buf[SWITCH_DEBOUNCE_SAMPLES]; // debounce buffer (private)
	u8	index;												// current buffer index
	u16 current;											// states bitfield (private)
	u16 previous;											// states bitfield (private)
	u16 raw;													// switch states bitfield (private)
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

// Get the state of a single switch
enum switch_state switch_x16_state(struct switch_x16_ctx* ctx, u8 index);
enum switch_state switch_x8_state(struct switch_x8_ctx* ctx, u8 index);

bool switchx16_was_pressed(struct switch_x16_ctx*, u8 index);
bool switchx16_was_released(struct switch_x16_ctx*, u8 index);
bool switchx8_was_pressed(struct switch_x8_ctx*, u8 index);
bool switchx8_was_released(struct switch_x8_ctx*, u8 index);

// Get the state of all switches as a bitfield
u16 switch_x16_states(struct switch_x16_ctx* ctx);
u8	switch_x8_states(struct switch_x8_ctx* ctx);

/**
 * @brief Run the debounce algorithm for all switches.
 *
 * @param ctx Switch context.
 */
void switch_x8_debounce(struct switch_x8_ctx* ctx);
void switch_x16_debounce(struct switch_x16_ctx* ctx);

/**
 * @brief Switch update functions are to be called after you have polled
 * the switch GPIO and retrieved their raw states. As an example:
 *
 * 1. Create a bitfield to store the switch states, set to 0
 * u8 state_bitfield = 0x00;
 *
 * 2. Retrieve the state of each switch, set the corresponding bit in the
 * bitfield for (int i = 0; i < 8; ++i) { state_bitfield |=
 * (get_state_of_gpio(i) << i);
 * }
 *
 * 3. Call switch update.
 * switch_x8_update(ctx, state_bitfield);
 *
 * @param ctx Switch context.
 * @param states Bitfield of switch states.
 */
void switch_x16_update(struct switch_x16_ctx* ctx, u16 states);
void switch_x8_update(struct switch_x8_ctx* ctx, u8 states);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/io/encoder.h
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define ENC_MAX		(UINT8_MAX)		// Maximum encoder value
#define ENC_MIN		(0)						// Minimum encoder value
#define ENC_MID		(ENC_MAX / 2) // Mid position encoder value
#define ENC_RANGE (u8)(ENC_MAX - ENC_MIN)

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

struct encoder_movement {
	i16 velocity;					// Current rotational velocity
	u8	accel_mode;				// Acceleration mode (Currently unused, placeholder)
	i8	direction;				// Current direction (-1, 0, 1)
	u32 last_update_time; // Last time the encoder was updated
	u16 accel_factor;			// Acceleration factor (1-7)
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief Initialises a single encoder context.
 *
 * @param enc Pointer to encoder device.
 * @return 0 on success, !0 on failure.
 */
int encoder_movement_init(struct encoder_movement* enc);

/**
 * @brief Perform an update of an encoder.
 * This function takes as input the hardware state of channel A and B
 * of the quadrature encoder, it then processes any change in encoder state
 * and generates an encoder rotation event if required.
 *
 * This uses a time-based acceleration algorithm to calculate the velocity
 * based on how quickly the encoder is turned.
 *
 * @param enc Pointer to encoder device.
 * @param direction Current direction of encoder (-1, 0, +1)
 * @return 1 if display needs to be updated
 */
bool encoder_movement_update(struct encoder_movement* enc, int direction);
// filepath: ./include/led/hsv2rgb.h
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2016  B. Stultiens
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
#ifndef __HSV_FAST_HSV2RGB_H__
#define __HSV_FAST_HSV2RGB_H__

#include <stdint.h>

#define HSV_HUE_SEXTANT			 256
#define HSV_HUE_STEPS				 (6 * HSV_HUE_SEXTANT)

#define HSV_HUE_MIN					 0
#define HSV_HUE_MAX					 (HSV_HUE_STEPS - 1)
#define HSV_SAT_MIN					 0
#define HSV_SAT_MAX					 255
#define HSV_VAL_MIN					 0
#define HSV_VAL_MAX					 255

/* Options: */
#define HSV_USE_SEXTANT_TEST /* Limit the hue to 0...360 degrees */
#define HSV_USE_ASSEMBLY		 /* Optimize code using assembly */

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The "used" attribute is required in the assembly version because Arduino
 * uses lto. With lto, the function is inlined into the rest of the code, which
 * eliminates the pointers to r, g, and b. However, the code requires pointers
 * because we need to do pointer swapping.
 * Adding the attribute to the function here forces gcc/linker to add the
 * function separately to the code and it must be called, just like other
 * library functions.
 */
#ifdef HSV_USE_ASSEMBLY
#define HSVFUNC_ATTRUSED __attribute__((used))
#else
#define HSVFUNC_ATTRUSED
#endif

void fast_hsv2rgb_8bit(uint16_t h, uint8_t s, uint8_t v, uint8_t* r, uint8_t* g,
											 uint8_t* b) HSVFUNC_ATTRUSED;
void fast_hsv2rgb_32bit(uint16_t h, uint8_t s, uint8_t v, uint8_t* r,
												uint8_t* g, uint8_t* b) HSVFUNC_ATTRUSED;

#ifdef __cplusplus
}
#endif

/*
 * Macros that are common to all implementations
 */
#define HSV_MONOCHROMATIC_TEST(s, v, r, g, b)                                  \
	do {                                                                         \
		if (!(s)) {                                                                \
			*(r) = *(g) = *(b) = (v);                                                \
			return;                                                                  \
		}                                                                          \
	} while (0)

#ifdef HSV_USE_SEXTANT_TEST
#define HSV_SEXTANT_TEST(sextant)                                              \
	do {                                                                         \
		if ((sextant) > 5) {                                                       \
			(sextant) = 5;                                                           \
		}                                                                          \
	} while (0)
#else
#define HSV_SEXTANT_TEST(sextant)                                              \
	do {                                                                         \
		;                                                                          \
	} while (0)
#endif

/*
 * Pointer swapping:
 * 	sext.	r g b	r<>b	g<>b	r <> g	result
 *	0 0 0	v u c			!u v c	u v c
 *	0 0 1	d v c				d v c
 *	0 1 0	c v u	u v c			u v c
 *	0 1 1	c d v	v d c		d v c	d v c
 *	1 0 0	u c v		u v c		u v c
 *	1 0 1	v c d		v d c	d v c	d v c
 *
 * if(sextant & 2)
 * 	r <-> b
 *
 * if(sextant & 4)
 * 	g <-> b
 *
 * if(!(sextant & 6) {
 * 	if(!(sextant & 1))
 * 		r <-> g
 * } else {
 * 	if(sextant & 1)
 * 		r <-> g
 * }
 */
#define HSV_SWAPPTR(a, b)                                                      \
	do {                                                                         \
		uint8_t* tmp = (a);                                                        \
		(a)					 = (b);                                                        \
		(b)					 = tmp;                                                        \
	} while (0)
#define HSV_POINTER_SWAP(sextant, r, g, b)                                     \
	do {                                                                         \
		if ((sextant) & 2) {                                                       \
			HSV_SWAPPTR((r), (b));                                                   \
		}                                                                          \
		if ((sextant) & 4) {                                                       \
			HSV_SWAPPTR((g), (b));                                                   \
		}                                                                          \
		if (!((sextant) & 6)) {                                                    \
			if (!((sextant) & 1)) {                                                  \
				HSV_SWAPPTR((r), (g));                                                 \
			}                                                                        \
		} else {                                                                   \
			if ((sextant) & 1) {                                                     \
				HSV_SWAPPTR((r), (g));                                                 \
			}                                                                        \
		}                                                                          \
	} while (0)

#if defined(HSV_USE_ASSEMBLY)

#if defined(__AVR_HAVE_MUL__)
/* Multiply instruction available */
#define MUL(ra, rb, pfx) "mul	" ra ", " rb "\n\t"
#else /* defined(__AVR_HAVE_MUL__) */
/*
 * Small AVR cores (f.x. ATtiny and ATmega*u2) do not have a mul instruction.
 * It is available from the avr4 architecture.
 *
 * Multiply: r1:r0 = ra * rb (clobbers r19, r17, r16)
 * Algorithm:
 * uint16_t mul(uint8_t ra, uint8_t rb)
 * {
 *	r1:r0   = 0
 *	r19     = ra
 *	r17:r16 = rb
 *	do {
 *		if(r19 & 1)
 *			r1:r0 += r17:r16
 *		r17:r16 += r17:r16
 *		r19 >>= 1;
 *	} while(r19)
 *	return r1:r0
 * }
 */
#define MUL(ra, rb, pfx)                                                       \
	"\n"                                                                         \
	".L" pfx "mul_" ra "_" rb "_%=:\n\t"                                         \
	"clr	r0\n\t"                                                                 \
	"clr	r1\n\t"                                                                 \
	"mov	r19, " ra "\n\t"                                                       \
	"mov	r16, " rb "\n\t"                                                       \
	"clr	r17\n"                                                                  \
	".L" pfx "mul_loop_" ra "_" rb "_%=:\n\t"                                    \
	"sbrc	r19, 0\n\t"                                                            \
	"add	r0, r16\n\t"                                                            \
	"sbrc	r19, 0\n\t"                                                            \
	"adc	r1, r17\n\t"                                                            \
	"add	r16, r16\n\t"                                                           \
	"adc	r17, r17\n\t"                                                           \
	"lsr	r19\n\t"                                                                \
	"brne	.L" pfx "mul_loop_" ra "_" rb "_%=\n\t"
#endif /* defined(__AVR_HAVE_MUL__) */

#if defined(__AVR_HAVE_MOVW__)
#define MOVW(rdh, rdl, rsh, rsl) "movw	" rdl ", " rsl "\n\t"
#else /* defined(__AVR_HAVE_MOVW__) */
/*
 * The avr2 (and avr1) architecture is missing the movw instruction
 * (ATtiny22/26/1* and AT90s*). All others should have it.
 */
#define MOVW(rdh, rdl, rsh, rsl)                                               \
	"mov	" rdl ", " rsl "\n\t"                                                  \
	"mov	" rdh ", " rsh "\n\t"
#endif /* defined(__AVR_HAVE_MOVW__) */
#endif /* defined(HSV_USE_ASSEMBLY) */

#endif
// filepath: ./include/led/rgb.h
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

struct rgb_8 {
	u8 red;
	u8 green;
	u8 blue;
};

struct rb_8 {
	u8 red;
	u8 blue;
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/led/color.h
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/**
 * @file color.h
 * @brief HSV color system with gamma correction for RGB LEDs
 *
 * This module provides functionality for HSV color manipulation with gamma
 * correction to ensure visually linear LED brightness responses. It includes
 * conversion between HSV and RGB color spaces and lookup tables for gamma
 * correction.
 */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

// HSV hue step definitions
#define HSV_HUE_STEPS                                                          \
	1536 // 0-1535 range for finer control (maps to 0-360 degrees)

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

extern const uint8_t gamma_corrected_lut_red[256];
extern const uint8_t gamma_corrected_lut_green[256];
extern const uint8_t gamma_corrected_lut_blue[256];

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief HSV Color structure
 *
 * Represents a color in the HSV (Hue, Saturation, Value) color space.
 * Hue: 0-1535 (0-360 degrees) - 0=red, 512=green, 1024=blue
 * Saturation: 0-255 (0-100%)
 * Value: 0-255 (0-100%)
 */
struct hsv_color {
	uint16_t hue;				 // 0-1535 (0-360 degrees)
	uint8_t	 saturation; // 0-255
	uint8_t	 value;			 // 0-255
};

// Forward declare virtmap structure to avoid circular dependencies
struct virtmap;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief Updates RGB values from HSV color space with gamma correction
 *
 * Converts the HSV color values stored in the virtmap to RGB values,
 * then applies gamma correction to produce BCM-compatible brightness levels.
 *
 * @param vmap Pointer to the virtmap structure containing HSV color values
 */
void color_update_vmap_rgb(struct virtmap* vmap);

/**
 * @brief Set HSV values for a specific virtmap and update RGB
 *
 * @param bank Bank index
 * @param enc Encoder index
 * @param vmap_idx Virtmap index
 * @param h Hue (0-1535)
 * @param s Saturation (0-255)
 * @param v Value (0-255)
 */
void color_set_vmap_hsv(uint8_t bank, uint8_t enc, uint8_t vmap_idx, uint16_t h,
												uint8_t s, uint8_t v);

/**
 * @brief Set linear RGB values for a specific virtmap with indices
 *
 * @param bank Bank index
 * @param enc Encoder index
 * @param vmap_idx Virtmap index
 * @param r_linear Red linear value (0-255)
 * @param g_linear Green linear value (0-255)
 * @param b_linear Blue linear value (0-255)
 */
void color_set_vmap_rgb_linear_by_index(uint8_t bank, uint8_t enc,
																				uint8_t vmap_idx, uint8_t r_linear,
																				uint8_t g_linear, uint8_t b_linear);

/**
 * @brief Sets linear RGB values with gamma correction
 *
 * Takes linear RGB values (0-255) and converts them to gamma-corrected
 * BCM values (0-31) for display on the LEDs.
 *
 * @param vmap Pointer to the virtmap structure
 * @param r_linear Red component (0-255)
 * @param g_linear Green component (0-255)
 * @param b_linear Blue component (0-255)
 */
void color_set_vmap_rgb_linear(struct virtmap* vmap, uint8_t r_linear,
															 uint8_t g_linear, uint8_t b_linear);

/**
 * @brief Set BCM RGB values directly for a specific virtmap with indices
 *
 * @param bank Bank index
 * @param enc Encoder index
 * @param vmap_idx Virtmap index
 * @param r_bcm Red BCM value (0-31)
 * @param g_bcm Green BCM value (0-31)
 * @param b_bcm Blue BCM value (0-31)
 */
void color_set_vmap_rgb_bcm_by_index(uint8_t bank, uint8_t enc,
																		 uint8_t vmap_idx, uint8_t r_bcm,
																		 uint8_t g_bcm, uint8_t b_bcm);

/**
 * @brief Sets BCM RGB values directly
 *
 * Allows direct setting of the BCM RGB values (0-31) without gamma correction.
 * This is useful for direct control of the LED brightness levels.
 *
 * @param vmap Pointer to the virtmap structure
 * @param r_bcm Red BCM value (0-31)
 * @param g_bcm Green BCM value (0-31)
 * @param b_bcm Blue BCM value (0-31)
 */
void color_set_vmap_rgb_bcm(struct virtmap* vmap, uint8_t r_bcm, uint8_t g_bcm,
														uint8_t b_bcm);

/**
 * @brief Print the gamma lookup table for a specific color channel
 *
 * @param channel Color channel ('r', 'g', or 'b')
 */
void color_print_gamma_lut(char channel);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/led/led.h
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief Initialise the display hardware and driver.
 *
 * @return int 0 on success, !0 on failure
 */
int display_init(void);

/**
 * @brief Periodic display update.
 */
void display_update(void);
// filepath: ./include/console/console.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2025) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#ifndef COMMON_CONSOLE_CONSOLE_H
#define COMMON_CONSOLE_CONSOLE_H

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>				// required for  snprintf_P
#include <avr/pgmspace.h> // for PSTR and PROGMEN macros

#ifdef __cplusplus
extern "C" {
#endif

#define CONSOLE_LINE_BUFFER_SIZE                                               \
	128 // Define the size of the console line buffer

/**
 * @brief Initializes the console module.
 */
void console_init(void);

/**
 * @brief Updates the console module state.
 *
 * This function should be called periodically in the main loop.
 * It checks for incoming serial data, processes commands, and handles output.
 */
void console_update(void);

/**
 * @brief Sends a single character to the console.
 *
 * @param c The character to send.
 */
void console_putc(char c);

/**
 * @brief Sends a null-terminated string to the console.
 *
 * @param str The string to send.
 */
void console_puts(const char* str);

/**
 * @brief Sends a null-terminated string from program memory to the console.
 *
 * @param str_p Pointer to the string in program memory.
 */
void console_puts_p(const char* str_p);

/**
 * @brief Prints an integer value to the console.
 *
 * @param value The integer value to print.
 */
#define console_put_int(value)	 console_put_value(PSTR("%d\r\n"), value)

/**
 * @brief Prints an unsigned integer value to the console.
 *
 * @param value The unsigned integer value to print.
 */
#define console_put_uint(value)	 console_put_value(PSTR("%u\r\n"), value)

/**
 * @brief Prints a floating point value to the console.
 *
 * @param value The floating point value to print.
 */
#define console_put_float(value) console_put_value(PSTR("%.2f\r\n"), value)

/**
 * @brief Prints a hexadecimal value to the console.
 *
 * @param value The hexadecimal value to print.
 */
#define console_put_hex(value)	 console_put_value(PSTR("0x%08X\r\n"), value)

/**
 * @brief Prints the production signature row values to the console.
 *
 * This function reads each non-reserved field from the production signature row
 * and prints its name and value to the console.
 */
void console_print_signature_row(void);

#define console_put_value(format_pstr, value)                                  \
	do {                                                                         \
		char buffer[CONSOLE_LINE_BUFFER_SIZE];                                     \
		snprintf_P(buffer, sizeof(buffer), format_pstr, value);                    \
		console_puts(buffer);                                                      \
	} while (0)

#ifdef __cplusplus
}
#endif

#endif // COMMON_CONSOLE_CONSOLE_H
// filepath: ./include/system/rng.h
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2025) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief Initialises the random number generator
 */
void rng_init(void);

/**
 * @brief Returns the current seed used by the random number generator
 *
 * @return The current seed
 */
uint32_t rng_get_seed(void);
// filepath: ./include/system/time.h
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief Start the system time.
 */
void systime_start(void);

/**
 * @brief Get the system time.
 *
 * @return u32 Current time in milliseconds.
 */
u32 systime_ms(void);
// filepath: ./include/system/types.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <assert.h>

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum isr_priority {
	PRIORITY_OFF,
	PRIORITY_LOW,
	PRIORITY_MED,
	PRIORITY_HI,

	PRIORITY_NB,
};

enum endian {
	ENDIAN_LSB,
	ENDIAN_MSB,
};

typedef uint8_t			 u8;
typedef uint16_t		 u16;
typedef uint32_t		 u32;
typedef unsigned int uint;

typedef volatile uint8_t			vu8;
typedef volatile uint16_t			vu16;
typedef volatile uint32_t			vu32;
typedef volatile unsigned int vuint;

typedef int8_t	i8;
typedef int16_t i16;
typedef int32_t i32;

typedef volatile int8_t	 vi8;
typedef volatile int16_t vi16;
typedef volatile int32_t vi32;

typedef float	 f32;
typedef double f64;

typedef uintptr_t uptr;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/system/config.h
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* Amount of time (ms) that an encoder will ignore external events
	after it has recently moved */
#define DEFAULT_ENC_PLAYDEAD_TIME	 (80)

#define DEFAULT_MIDI_THROTTLE_TIME (10)

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

struct sys_config {
	u8 enc_dead_time;
	u8 midi_throttle_time;
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/system/error.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <assert.h>

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief Checks the value of an error code, jumps to l if it is not == success.
 * @warning DO NOT PASS/CALL FUNCTIONS WITH THIS MACRO.
 * @param s Error/status code to check.
 * @param l Label to goto.
 */
#define EXIT_ON_ERR(s, l)                                                      \
	do {                                                                         \
		if (s != SUCCESS) {                                                        \
			goto l;                                                                  \
		}                                                                          \
	} while (0)

/**
 * @brief Checks the value of an error code and returns if it is not == success.
 * @warning DO NOT PASS/CALL FUNCTIONS WITH THIS MACRO.
 * @param s Error/status code to check.
 */
#define RETURN_ON_ERR(s)                                                       \
	do {                                                                         \
		if (s != SUCCESS) {                                                        \
			return s;                                                                \
		}                                                                          \
	} while (0)

/**
 * @brief Checks if a pointer is NULL, jumps to l if true.
 * @warning DO NOT PASS/CALL FUNCTIONS WITH THIS MACRO.
 * @param p Pointer to check against null.
 * @param l Label to goto.
 */
#define EXIT_IF_NULL(p, l)                                                     \
	do {                                                                         \
		if (p == NULL) {                                                           \
			goto l;                                                                  \
		}                                                                          \
	} while (0)

/**
 * @brief Checks if a pointer is null, returns ERR_NULL_PTR if true.
 * @warning DO NOT PASS/CALL FUNCTIONS WITH THIS MACRO.
 * @param p Pointer to check against null.
 * @param l Label to goto.
 */
#define RETURN_ERR_IF_NULL(p)                                                  \
	do {                                                                         \
		if (p == NULL) {                                                           \
			return ERR_NULL_PTR;                                                     \
		}                                                                          \
	} while (0)

/**
 * @brief Checks if a pointer is null, returns if true.
 * @warning DO NOT PASS/CALL FUNCTIONS WITH THIS MACRO.
 * @param p Pointer to check against null.
 */
#define RETURN_IF_NULL(p)                                                      \
	do {                                                                         \
		if (p == NULL) {                                                           \
			return;                                                                  \
		}                                                                          \
	} while (0)

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum return_code {
	SUCCESS							= 0,
	ERR_BAD_PARAM				= -1,
	ERR_NULL_PTR				= -2,
	ERR_UNSUPPORTED			= -3,
	ERR_STUB						= -4,
	ERR_NO_MEM					= -5,
	ERR_DUPLICATE				= -6,
	ERR_NOT_IMPLEMENTED = -7,
	ERR_BAD_MSG					= -8,
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/system/opmode.h
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum opmode {
	OPMODE_NORMAL,
	OPMODE_CONFIG,

	OPMODE_NB,
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/system/hardware.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "hal/sys.h"
#include "system/types.h"
#include "system/config.h"
#include "io/quadrature.h"
#include "io/encoder.h"
#include "io/switch.h"

#include "virtmap/virtmap.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define NUM_ENCODERS							(16)
#define NUM_ENCODER_SWITCHES			(NUM_ENCODERS)
#define NUM_SIDE_SWITCHES					(6)
#define NUM_LEDS									(256)
#define NUM_LEDS_PER_ENCODER			(16)
#define NUM_INDICATOR_LEDS				(11)
#define NUM_LED_SHIFT_REGISTERS		(32)
#define NUM_INPUT_SHIFT_REGISTERS (6)
#define NUM_PWM_FRAMES						(32)

#define MAX_BRIGHTNESS						(NUM_PWM_FRAMES)
#define MIN_BRIGHTNESS						(0)

#define NUM_ENC_BANKS							(3)
#define NUM_ENC_PER_BANK					(NUM_ENCODERS)
#define NUM_VMAPS_PER_ENC					(2)

#define RGB_WHITE									(0x32DF) // red = max, blue = 12, green = 22
#define RGB_MAX_VAL								(NUM_PWM_FRAMES)

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum display_mode {
	DIS_MODE_SINGLE,
	DIS_MODE_MULTI,
	DIS_MODE_MULTI_PWM,

	DIS_MODE_NB,
};

enum side_switch_mode {
	// Do nothing
	SIDE_SW_MODE_NONE,

	// Cycle through vmaps on all encoders on press
	SIDE_SW_MODE_ALL_VMAP_CYCLE,

	// Temporarily change vmaps on all encoders while held
	SIDE_SW_MODE_ALL_VMAP_HOLD,

	// Bank switching (decrease)
	SIDE_SW_MODE_BANK_PREV,

	// Bank switching (increase)
	SIDE_SW_MODE_BANK_NEXT,

	// Reserved for future functionality
	SIDE_SW_MODE_RESERVED,
};

enum switch_mode {
	SW_MODE_NONE,

	// Cycle between virtual mappings on press
	SW_MODE_VMAP_CYCLE,

	// Alternative virtual mapping active while switch held
	SW_MODE_VMAP_HOLD,

	// Reset encoder value on press
	SW_MODE_RESET_ON_PRESS,

	// Reset encoder value on release
	SW_MODE_RESET_ON_RELEASE,

	// Toggle fine adjust mode on press
	SW_MODE_FINE_ADJUST_TOGGLE,

	// Fine adjust mode active while switch held
	SW_MODE_FINE_ADJUST_HOLD,

	// Switch actives a MIDI event (CC, Note, etc)
	SW_MODE_MIDI,
};

struct encoder {
	// Hardware index (0 to 15)
	u8 idx;

	// Display Configuration
	struct {
		enum display_mode					mode;
		enum virtmap_display_mode virtmode;
	} display;

	// Encoder
	bool										detent;
	struct encoder_movement enc_ctx;
	struct quadrature*			quad_ctx;

	// Virtual Mappings
	enum virtmap_mode vmap_mode;
	u8								vmap_active; // Index for the current active vmap
	struct virtmap		vmaps[NUM_VMAPS_PER_ENC];

	// Encoder Switch
	enum switch_state sw_state;
	enum switch_mode	sw_mode;
	struct proto_cfg	sw_cfg;

	/*
		update_display is (as its name suggests) used to determine when to redraw
		the LEDs for this encoder. This is to prevent the display from being updated
		too frequently, and to allow for a smooth display update.
		It is effectively a timestamp (in ms) which can then be used to determine
		if the display should be updated.
		Normally the display only needs to be updated if the time delta between
		the last update and the current time is greater than a certain threshold.

		A value of 0 means the display is up-to-date (and can therefore be skipped
		by the update routine).
	*/
	u32 update_display;
};

struct side_switch {
	// Mode of operation for this switch
	enum side_switch_mode mode;

	// Current state of the switch
	enum switch_state state;

	// Previous vmap_active values for ALL encoders (used for SIDE_SW_MODE_ALL_VMAP_HOLD)
	u8 prev_vmap_active[NUM_ENCODERS];
};

/**
 * @brief Runtime data structure for the midifighter global variables.
 */
struct mf_rt {
	u8 curr_bank;
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

extern volatile u16			 gFRAME_BUFFER[NUM_PWM_FRAMES][NUM_ENCODERS];
extern struct quadrature gQUAD_ENC[NUM_ENCODER_SWITCHES];
extern struct encoder		 gENCODERS[NUM_ENC_BANKS][NUM_ENCODERS];
extern struct side_switch gSIDE_SWITCHES[NUM_SIDE_SWITCHES];
extern struct mf_rt			 gRT;
extern struct sys_config gCONFIG;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

void hw_led_init(void);

void hw_encoder_init(void);
void hw_encoder_scan(void);

void							hw_switch_init(void);
void							hw_switch_update(void);
enum switch_state hw_enc_switch_state(u8 idx);
enum switch_state hw_side_switch_state(u8 idx);

void input_init(void);
void input_update(void);
bool is_reset_pressed(void);

int mf_display_init(void);
int mf_draw_encoder(struct encoder* enc);

void mf_debug_encoder_set_indicator(u8 indicator, u8 state);
void mf_debug_encoder_set_rgb(bool red, bool green, bool blue);

/**
 * @brief Initialise the midifighter configuration data.
 * This will read/write to the EEPROM.
 * The function must be called AFTER all other initialisation functions,
 * to ensure that default configurations will be correctly written
 * the very first time a user boots the device.
 *
 * @return int 0 on success, !0 on failure.
 */
int cfg_init(bool reset_cfg);
int cfg_load(void);
int cfg_store(void);
int cfg_update(void);
int mf_cfg_reset(void);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/system/utility.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <assert.h>

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

// Static assertions, b = boolean expression, s = error message on failure
#define STATIC_ASSERT(b, s)		_Static_assert(b, s)

// Check if a value is within a range (inclusive)
#define IN_RANGE(x, min, max) (((x) >= min) && ((x) <= max))

// Clamp a value between a min and max
#define CLAMP(x, min, max)		((x) < (min) ? (min) : ((x) > (max) ? (max) : (x)))

// Get the min value of two values
#define MIN(a, b)							((a) < (b) ? (a) : (b))

// Get the max value of two values
#define MAX(a, b)							((a) > (b) ? (a) : (b))

// Get the number of elements in an array
#define COUNTOF(a)						(sizeof(a) / sizeof(*(a)))

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */

__attribute__((__gnu_inline__)) static inline i32
convert_range_i32(i32 c, i32 omin, i32 omax, i32 nmin, i32 nmax) {
	const i32 or = omax - omin;
	const i32 nr = nmax - nmin;

	return (((c - omin) * nr) / or) + nmin;
}

__attribute__((__gnu_inline__)) static inline i16
convert_range_i16(i16 c, i16 omin, i16 omax, i16 nmin, i16 nmax) {
	const i16 or = omax - omin;
	const i16 nr = nmax - nmin;

	return (((c - omin) * nr) / or) + nmin;
}
// filepath: ./include/system/print.h
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <avr/pgmspace.h>

#include "system/types.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#ifdef ENABLE_CONSOLE
#define println_pmem(s) (println_progmem(PSTR(s)))
void println_progmem(const char* const str);
void println(const char* const str);
void printbuf(u8* buf, uint len);
#else
#define println_pmem(str)
#define println(str)
#define printbuf(b, l)
#endif
// filepath: ./include/protocol/protocol.h
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "midi/midi.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum protocol_type {
	PROTOCOL_NONE,

	PROTOCOL_MIDI,
	PROTOCOL_OSC,

	PROTOCOL_NB,
};

struct proto_cfg {
	enum protocol_type type;

	union {
		struct midi_cfg midi;
		// osc...
	};
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/usb/usb_lufa.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "LUFA/Drivers/USB/USB.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define USB_VENDOR_ID								0x2580
#define USB_PRODUCT_ID							0x0007
#define USB_HID_EPSIZE							32
#define USB_KEYBOARD_EPSIZE					8
#define USB_MOUSE_EPSIZE						8
#define USB_MIDI_STREAM_EPSIZE			64
#define USB_CDC_NOTIFICATION_EPSIZE 8
#define USB_CDC_EPSIZE							16
#define USB_MIDI_POLLING_INTERVAL		0x05

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum usb_interface {

#ifdef ENABLE_CONSOLE
	CCI_INTERFACE,
	CDI_INTERFACE,
#endif

	MIDI_AC_INTERFACE, // Audio control interface
	MIDI_AS_INTERFACE, // Audio stream interface

#ifdef HID_ENABLE
	HID_INTERFACE,
#endif

	NUM_USB_INTERFACES
};

enum usb_str_desc {
	STRING_ID_Language		 = 0,
	STRING_ID_Manufacturer = 1,
	STRING_ID_Product			 = 2,
	STRING_ID_Serial			 = 3,
};

enum usb_endpoint {
	USB_EP_RESERVED,

	USB_EP_MIDI_STREAM_IN,
	USB_EP_MIDI_STREAM_OUT,

#ifdef HID_ENABLE
	HID_EPNUM,
#endif

#ifdef ENABLE_CONSOLE
	CDC_NOTIFICATION_EPNUM,
	CDC_IN_EPNUM,
	CDC_OUT_EPNUM,
#endif

	USB_EP_NB, // must be less than 5
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/usb/LUFAConfig.h
/*
			 LUFA Library
	 Copyright (C) Dean Camera, 2021.

	dean [at] fourwalledcubicle [dot] com
			 www.lufa-lib.org
*/

/*
	Copyright 2021  Dean Camera (dean [at] fourwalledcubicle [dot] com)

	Permission to use, copy, modify, distribute, and sell this
	software and its documentation for any purpose is hereby granted
	without fee, provided that the above copyright notice appear in
	all copies and that both that the copyright notice and this
	permission notice and warranty disclaimer appear in supporting
	documentation, and that the name of the author not be used in
	advertising or publicity pertaining to distribution of the
	software without specific, written prior permission.

	The author disclaims all warranties with regard to this
	software, including all implied warranties of merchantability
	and fitness.  In no event shall the author be liable for any
	special, indirect or consequential damages or any damages
	whatsoever resulting from loss of use, data or profits, whether
	in an action of contract, negligence or other tortious action,
	arising out of or in connection with the use or performance of
	this software.
*/

/** \file
 *  \brief LUFA Library Configuration Header File (Template)
 *
 *  This is a header file which can be used to configure LUFA's
 *  compile time options, as an alternative to the compile time
 *  constants supplied through a makefile. To use this configuration
 *  header, copy this into your project's root directory and supply
 *  the \c USE_LUFA_CONFIG_HEADER token to the compiler so that it is
 *  defined in all compiled source files.
 *
 *  For information on what each token does, refer to the LUFA
 *  manual section "Summary of Compile Tokens".
 */

#ifndef __LUFA_CONFIG_H__
#define __LUFA_CONFIG_H__

#if (ARCH == ARCH_XMEGA)

/* Non-USB Related Configuration Tokens: */
//		#define DISABLE_TERMINAL_CODES

/* USB Class Driver Related Tokens: */
//		#define HID_HOST_BOOT_PROTOCOL_ONLY
//		#define HID_STATETABLE_STACK_DEPTH       {Insert Value Here}
//		#define HID_USAGE_STACK_DEPTH            {Insert Value Here}
//		#define HID_MAX_COLLECTIONS              {Insert Value Here}
//		#define HID_MAX_REPORTITEMS              {Insert Value Here}
//		#define HID_MAX_REPORT_IDS               {Insert Value Here}
//		#define NO_CLASS_DRIVER_AUTOFLUSH

/* General USB Driver Related Tokens: */
#define USE_STATIC_OPTIONS                                                     \
	(USB_DEVICE_OPT_FULLSPEED | USB_OPT_RC32MCLKSRC | USB_OPT_BUSEVENT_PRILOW)
// #define USE_STATIC_OPTIONS (USB_DEVICE_OPT_FULLSPEED | USB_OPT_REG_ENABLED |
// USB_OPT_AUTO_PLL)
//		#define USB_STREAM_TIMEOUT_MS            {Insert Value Here}
#define NO_LIMITED_CONTROLLER_CONNECT
#define NO_SOF_EVENTS

/* USB Device Mode Driver Related Tokens: */
//		#define USE_RAM_DESCRIPTORS
#define USE_FLASH_DESCRIPTORS
//		#define USE_EEPROM_DESCRIPTORS
//		#define NO_INTERNAL_SERIAL
#define FIXED_CONTROL_ENDPOINT_SIZE (64)
//		#define DEVICE_STATE_AS_GPIOR            {Insert Value Here}
#define FIXED_NUM_CONFIGURATIONS		(1)
//		#define CONTROL_ONLY_DEVICE
#define MAX_ENDPOINT_INDEX					(5)
//		#define NO_DEVICE_REMOTE_WAKEUP
#define NO_DEVICE_SELF_POWER

#else

#error Unsupported architecture for this LUFA configuration file.

#endif
#endif
// filepath: ./include/usb/usb.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

int usb_init(void);
int usb_update(void);

// Function to check if the virtual serial port is active (DTR asserted)
bool usb_cdc_is_active(void);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/midi/midi_cc.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define MIDI_CC_MIN				(MIDI_CC_MSB_BANK)
#define MIDI_CC_MAX				(MIDI_CC_MONO2)
#define MIDI_CC_RANGE			(MIDI_CC_MAX - MIDI_CC_MIN)

#define MIDI_CC_14B_MIN		(0)
#define MIDI_CC_14B_MAX		(0x3FFF)
#define MIDI_CC_14B_RANGE (MIDI_CC_14B_MAX - MIDI_CC_14B_MIN)

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum midi_cc {
	MIDI_CC_MSB_BANK						 = 0x00,
	MIDI_CC_MSB_MODWHEEL				 = 0x01,
	MIDI_CC_MSB_BREATH					 = 0x02,
	MIDI_CC_MSB_FOOT						 = 0x04,
	MIDI_CC_MSB_PORTAMENTO_TIME	 = 0x05,
	MIDI_CC_MSB_DATA_ENTRY			 = 0x06,
	MIDI_CC_MSB_MAIN_VOLUME			 = 0x07,
	MIDI_CC_MSB_BALANCE					 = 0x08,
	MIDI_CC_MSB_PAN							 = 0x0a,
	MIDI_CC_MSB_EXPRESSION			 = 0x0b,
	MIDI_CC_MSB_EFFECT1					 = 0x0c,
	MIDI_CC_MSB_EFFECT2					 = 0x0d,
	MIDI_CC_MSB_GENERAL_PURPOSE1 = 0x10,
	MIDI_CC_MSB_GENERAL_PURPOSE2 = 0x11,
	MIDI_CC_MSB_GENERAL_PURPOSE3 = 0x12,
	MIDI_CC_MSB_GENERAL_PURPOSE4 = 0x13,
	MIDI_CC_LSB_BANK						 = 0x20,
	MIDI_CC_LSB_MODWHEEL				 = 0x21,
	MIDI_CC_LSB_BREATH					 = 0x22,
	MIDI_CC_LSB_FOOT						 = 0x24,
	MIDI_CC_LSB_PORTAMENTO_TIME	 = 0x25,
	MIDI_CC_LSB_DATA_ENTRY			 = 0x26,
	MIDI_CC_LSB_MAIN_VOLUME			 = 0x27,
	MIDI_CC_LSB_BALANCE					 = 0x28,
	MIDI_CC_LSB_PAN							 = 0x2a,
	MIDI_CC_LSB_EXPRESSION			 = 0x2b,
	MIDI_CC_LSB_EFFECT1					 = 0x2c,
	MIDI_CC_LSB_EFFECT2					 = 0x2d,
	MIDI_CC_LSB_GENERAL_PURPOSE1 = 0x30,
	MIDI_CC_LSB_GENERAL_PURPOSE2 = 0x31,
	MIDI_CC_LSB_GENERAL_PURPOSE3 = 0x32,
	MIDI_CC_LSB_GENERAL_PURPOSE4 = 0x33,
	MIDI_CC_SUSTAIN							 = 0x40,
	MIDI_CC_PORTAMENTO					 = 0x41,
	MIDI_CC_SOSTENUTO						 = 0x42,
	MIDI_CC_SOFT_PEDAL					 = 0x43,
	MIDI_CC_LEGATO_FOOTSWITCH		 = 0x44,
	MIDI_CC_HOLD2								 = 0x45,
	MIDI_CC_SC1_SOUND_VARIATION	 = 0x46,
	MIDI_CC_SC2_TIMBRE					 = 0x47,
	MIDI_CC_SC3_RELEASE_TIME		 = 0x48,
	MIDI_CC_SC4_ATTACK_TIME			 = 0x49,
	MIDI_CC_SC5_BRIGHTNESS			 = 0x4a,
	MIDI_CC_SC6									 = 0x4b,
	MIDI_CC_SC7									 = 0x4c,
	MIDI_CC_SC8									 = 0x4d,
	MIDI_CC_SC9									 = 0x4e,
	MIDI_CC_SC10								 = 0x4f,
	MIDI_CC_GENERAL_PURPOSE5		 = 0x50,
	MIDI_CC_GENERAL_PURPOSE6		 = 0x51,
	MIDI_CC_GENERAL_PURPOSE7		 = 0x52,
	MIDI_CC_GENERAL_PURPOSE8		 = 0x53,
	MIDI_CC_PORTAMENTO_CONTROL	 = 0x54,
	MIDI_CC_E1_REVERB_DEPTH			 = 0x5b,
	MIDI_CC_E2_TREMOLO_DEPTH		 = 0x5c,
	MIDI_CC_E3_CHORUS_DEPTH			 = 0x5d,
	MIDI_CC_E4_DETUNE_DEPTH			 = 0x5e,
	MIDI_CC_E5_PHASER_DEPTH			 = 0x5f,
	MIDI_CC_DATA_INCREMENT			 = 0x60,
	MIDI_CC_DATA_DECREMENT			 = 0x61,
	MIDI_CC_NONREG_PARM_NUM_LSB	 = 0x62,
	MIDI_CC_NONREG_PARM_NUM_MSB	 = 0x63,
	MIDI_CC_REGIST_PARM_NUM_LSB	 = 0x64,
	MIDI_CC_REGIST_PARM_NUM_MSB	 = 0x65,
	MIDI_CC_ALL_SOUNDS_OFF			 = 0x78,
	MIDI_CC_RESET_CONTROLLERS		 = 0x79,
	MIDI_CC_LOCAL_CONTROL_SWITCH = 0x7a,
	MIDI_CC_ALL_NOTES_OFF				 = 0x7b,
	MIDI_CC_OMNI_OFF						 = 0x7c,
	MIDI_CC_OMNI_ON							 = 0x7d,
	MIDI_CC_MONO1								 = 0x7e,
	MIDI_CC_MONO2								 = 0x7f,
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/midi/midi_sysex_nrt.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

// Sysex non-realtime subid #1
enum midi_sysex_nrt {
	SYSEX_NRT_SAMPLE_DUMP_HDR		 = 0x01, // Sample dump header
	SYSEX_NRT_SAMPLE_DUMP_PACKET = 0x02, // Sample dump packet
	SYSEX_NRT_SAMPLE_DUMP_REQ		 = 0x03, // Sample dump request
	SYSEX_NRT_MTC_CUEING				 = 0x04, // MIDI time code cueing
	SYSEX_NRT_SAMPLE_DUMPEXT		 = 0x05, // Sample dump extension
	SYSEX_NRT_GENERAL_SYS				 = 0x06, // General information
	SYSEX_NRT_FILE_DUMP					 = 0x07, // File dump
	SYSEX_NRT_TUNING_STANDARD		 = 0x08, // MIDI tuning standard
	SYSEX_NRT_GM								 = 0x09, // General MIDI
	SYSEX_NRT_DLS								 = 0x0A, // Downloadable sounds
	SYSEX_NRT_END_OF_FILE				 = 0x7B, // End of file
	SYSEX_NRT_WAIT							 = 0x7C, // Wait
	SYSEX_NRT_CANCEL						 = 0x7D, // Cancel
	SYSEX_NRT_NAK								 = 0x7E, // NAK
	SYSEX_NRT_ACK								 = 0x7F, // ACK
};

// Sysex non-realtime - midi timecode
enum midi_sysex_nrt_mtc {
	SYSEX_NRT_MTC_SPECIAL						 = 0x00,
	SYSEX_NRT_MTC_PUNCH_IN_POINTS		 = 0x01,
	SYSEX_NRT_MTC_PUNCH_OUT_POINTS	 = 0x02,
	SYSEX_NRT_MTC_PUNCH_IN_DELETE		 = 0x03,
	SYSEX_NRT_MTC_PUNCH_OUT_DELETE	 = 0x04,
	SYSEX_NRT_MTC_EVENT_START_POINT	 = 0x05,
	SYSEX_NRT_MTC_EVENT_STOP_POINT	 = 0x06,
	SYSEX_NRT_MTC_EVENT_START_ADDT	 = 0x07,
	SYSEX_NRT_MTC_EVENT_STOP_ADDT		 = 0x08,
	SYSEX_NRT_MTC_EVENT_START_DELETE = 0x09,
	SYSEX_NRT_MTC_EVENT_STOP_DELETE	 = 0x0A,
	SYSEX_NRT_MTC_CUE_POINTS				 = 0x0B,
	SYSEX_NRT_MTC_CUE_POINTS_ADDT		 = 0x0C,
	SYSEX_NRT_MTC_CUE_POINT_DELETE	 = 0x0D,
	SYSEX_NRT_MTC_EVENT_NAME_ADDT		 = 0x0E,
};

// Sysex non-realtime - sample dump extension
enum midi_sysex_nrt_sample_dump {
	SYSEX_NRT_SAMPLE_DUMPEXT_LOOP_POINT_TX			= 0x01,
	SYSEX_NRT_SAMPLE_DUMPEXT_LOOP_POINT_REQ			= 0x02,
	SYSEX_NRT_SAMPLE_DUMPEXT_NAME_TX						= 0x03,
	SYSEX_NRT_SAMPLE_DUMPEXT_NAME_REQ						= 0x04,
	SYSEX_NRT_SAMPLE_DUMPEXT_HEADER							= 0x05,
	SYSEX_NRT_SAMPLE_DUMPEXT_LOOP_POINT_TX_EXT	= 0x06,
	SYSEX_NRT_SAMPLE_DUMPEXT_LOOP_POINT_REQ_EXT = 0x07,
};

// Sysex non-realtime - general system information
enum midi_general_nrt_sys {
	SYSEX_NRT_GENERAL_SYS_ID_REQ = 0x01,
	SYSEX_NRT_GENERAL_SYS_ID_RES = 0x02,
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/midi/midi_sysex_rt.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

// Sysex realtime subid #1
enum midi_sysex_rt {
	SYSEX_RT_MTC						 = 0x01,
	SYSEX_RT_NOTATION				 = 0x03,
	SYSEX_RT_DEV_CTRL				 = 0x04,
	SYSEX_RT_MTC_CUEING			 = 0x05,
	SYSEX_RT_MMC						 = 0x06,
	SYSEX_RT_TUNING_STANDARD = 0x08,
};

// Sysex realtime - midi timecode
enum midi_sysex_rt_mtc {
	SYSEX_RT_MTC_FULL_MSG	 = 0x01,
	SYSEX_RT_MTC_USER_BITS = 0x02,
};

// Sysex realtime - notation
enum midi_sysex_rt_notation {
	SYSEX_RT_NOTATION_BAR_MARKER				 = 0x01,
	SYSEX_RT_NOTATION_TIME_SIG_IMMEDIATE = 0x02,
	SYSEX_RT_NOTATION_TIME_SIG_DELAYED	 = 0x42,
};

// Sysex realtime - device control
enum midi_sysex_rt_dev_ctrl {
	SYSEX_RT_DEV_CTRL_MASTER_VOL				 = 0x01,
	SYSEX_RT_DEV_CTRL_MASTER_BAL				 = 0x02,
	SYSEX_RT_DEV_CTRL_MASTER_FINE_TUNE	 = 0x03,
	SYSEX_RT_DEV_CTRL_MASTER_COARSE_TUNE = 0x04,
};

// Sysex realtime - midi timecode cueing
enum midi_sysex_rt_mtc_cueing {
	SYSEX_RT_MTC_CUE_PUNCH_IN_POINTS				= 0x01,
	SYSEX_RT_MTC_CUE_PUNCH_OUT_POINTS				= 0x02,
	SYSEX_RT_MTC_CUE_EVENT_START_POINT			= 0x05,
	SYSEX_RT_MTC_CUE_EVENT_STOP_POINT				= 0x06,
	SYSEX_RT_MTC_CUE_EVENT_START_ADDT_POINT = 0x07,
	SYSEX_RT_MTC_CUE_EVENT_STOP_ADDT_POINT	= 0x08,
	SYSEX_RT_MTC_CUE_POINTS									= 0x0B,
	SYSEX_RT_MTC_CUE_POINTS_ADDT						= 0x0C,
	SYSEX_RT_MTC_CUE_EVENT_NAME_ADDT				= 0x0E,
};

// Sysex realtime - midi machine control
enum midi_sysex_rt_mmc {
	SYSEX_RT_MMC_STOP								 = 0x01,
	SYSEX_RT_MMC_PLAY								 = 0x02,
	SYSEX_RT_MMC_DEFERRED_PLAY			 = 0x03,
	SYSEX_RT_MMC_FAST_FORWARD				 = 0x04,
	SYSEX_RT_MMC_REWIND							 = 0x05,
	SYSEX_RT_MMC_RECORD_STROBE			 = 0x06,
	SYSEX_RT_MMC_RECORD_EXIT				 = 0x07,
	SYSEX_RT_MMC_RECORD_PAUSE				 = 0x08,
	SYSEX_RT_MMC_PAUSE							 = 0x09,
	SYSEX_RT_MMC_EJECT							 = 0x0A,
	SYSEX_RT_MMC_CHASE							 = 0x0B,
	SYSEX_RT_MMC_COMMAND_ERROR_RESET = 0x0C,
	SYSEX_RT_MMC_RESET							 = 0x0D,
	SYSEX_RT_MMC_LOCATE							 = 0x44,
	SYSEX_RT_MMC_SHUTTLE						 = 0x47,
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/midi/midi_types.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define MIDI_MFR_ID_1 0x53 // 'S'
#define MIDI_MFR_ID_2 0x41 // 'A'
#define MIDI_MFR_ID_3 0x4D // 'M'

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum midi_msg_type {
	MIDI_MSG_CHANNEL_VOICE,
	MIDI_MSG_CHANNEL_MODE,
	MIDI_MSG_SYSTEM_EXCLUSIVE,
	MIDI_MSG_SYSTEM_COMMON,
	MIDI_MSG_SYSTEM_REALTIME,
	MIDI_MSG_INVALID,

	MIDI_MSG_NB,
};

// Status byte values for various message types
enum midi_status_byte {
	MIDI_STATUS_NOTE_OFF								= 0x80,
	MIDI_STATUS_NOTE_ON									= 0x90,
	MIDI_STATUS_POLY_KEY_PRESSURE				= 0xA0,
	MIDI_STATUS_CONTROL_CHANGE					= 0xB0,
	MIDI_STATUS_PROGRAM_CHANGE					= 0xC0,
	MIDI_STATUS_CHANNEL_PRESSURE				= 0xD0,
	MIDI_STATUS_PITCH_BEND							= 0xE0,
	MIDI_STATUS_SYSTEM_EXCLUSIVE				= 0xF0,
	MIDI_STATUS_TIME_CODE_QUARTER_FRAME = 0xF1,
	MIDI_STATUS_SONG_POSITION_POINTER		= 0xF2,
	MIDI_STATUS_SONG_SELECT							= 0xF3,
	MIDI_STATUS_TUNE_REQUEST						= 0xF6,
	MIDI_STATUS_END_OF_EXCLUSIVE				= 0xF7,
	MIDI_STATUS_TIMING_CLOCK						= 0xF8,
	MIDI_STATUS_START										= 0xFA,
	MIDI_STATUS_CONTINUE								= 0xFB,
	MIDI_STATUS_STOP										= 0xFC,
	MIDI_STATUS_ACTIVE_SENSING					= 0xFE,
	MIDI_STATUS_SYSTEM_RESET						= 0xFF,
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/midi/sysex.h
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/hardware.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define MF_SYSEX_MAX_PKT_SIZE	 (sizeof(mf_sysex_msg_s))
#define MF_SYSEX_MIN_PKT_SIZE	 (sizeof(mf_sysex_msg_s) - MF_SYSEX_MAX_DATA_SIZE)
#define MF_SYSEX_MAX_DATA_SIZE (sizeof(mf_sysex_param_s))

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum mf_sysex_cmd {
	MF_SYSEX_GET,
	MF_SYSEX_GET_RESPONSE,

	MF_SYSEX_SET,
	MF_SYSEX_SET_RESPONSE,

	MF_SYSEX_STOP,
};

enum mf_sysex_param {
	MF_SYSEX_PARAM_ENCODER_DETENT,
	MF_SYSEX_PARAM_ENCODER_DISPLAY_MODE,
	MF_SYSEX_PARAM_ENCODER_VMAP_DISPLAY_MODE,
	MF_SYSEX_PARAM_ENCODER_VMAP_MODE,
	MF_SYSEX_PARAM_ENCODER_VMAP_ACTIVE,

	MF_SYSEX_PARAM_ENCODER_SWITCH_STATE,
	MF_SYSEX_PARAM_ENCODER_SWITCH_MODE,
	MF_SYSEX_PARAM_ENCODER_SWITCH_PROTO,

	MF_SYSEX_PARAM_VMAP_RANGE,
	MF_SYSEX_PARAM_VMAP_POSITION,
	MF_SYSEX_PARAM_VMAP_RGB,
	MF_SYSEX_PARAM_VMAP_RB,
	MF_SYSEX_PARAM_VMAP_PROTO,

	MF_SYSEX_PARAM_SIDE_SWITCH,
	MF_SYSEX_PARAM_ACTIVE_BANK,

	MF_SYSEX_PARAM_NB,
};

typedef struct __attribute__((packed)) {
	u8 mode;
	u8 channel;
	u8 data; // CC/Note etc..
} mf_sysex_midi_cfg_s;

typedef struct __attribute__((packed)) {
	u8 type;
	union {
		mf_sysex_midi_cfg_s midi;
	};
} mf_sysex_proto_cfg_s;

typedef struct __attribute__((packed)) {
	u8 bank_idx;
	u8 enc_idx;
	union {
		u8												detent;
		enum display_mode					display_mode;
		enum virtmap_display_mode vmap_display_mode;
		enum virtmap_mode					vmap_mode;
		u8												vmap_active;
	} data;
} mf_sysex_encoder_param_s;

typedef struct __attribute__((packed)) {
	u8 bank_idx;
	u8 enc_idx;
	union {
		u8 data; // placeholder
	};
} mf_sysex_switch_param_s;

typedef struct __attribute__((packed)) {
	u8 sw_idx;
} mf_sysex_sideswitch_param_s;

typedef struct __attribute__((packed)) {
	u8 bank_idx;
	u8 enc_idx;
	u8 vmap_idx;
	union {
		struct {
			u8 lower;
			u8 upper;
		} range;
		struct {
			u8 start;
			u8 stop;
		} position;
		struct {
			u16 red;
			u16 green;
			u16 blue;
		} rgb;
		struct {
			u16 red;
			u16 blue;
		} rb;
	} data;
} mf_sysex_vmap_param_s;

typedef union {
	mf_sysex_encoder_param_s		enc;
	mf_sysex_sideswitch_param_s sw;
	mf_sysex_vmap_param_s				vmap;
} mf_sysex_param_s;

typedef struct __attribute__((packed)) {
	u8							 mf_id[3];
	u8							 cmd;
	u8							 param_enum;
	mf_sysex_param_s param;
} mf_sysex_msg_s;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

int mf_sysex_init(void);
// filepath: ./include/midi/midi.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"

#include "midi/midi_types.h"
#include "midi/midi_cc.h"
#include "midi/midi_sysex_nrt.h"
#include "midi/midi_sysex_rt.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum midi_mode {
	MIDI_MODE_DISABLED,
	MIDI_MODE_CC,
	MIDI_MODE_CC_14,
	MIDI_MODE_REL_CC,
	MIDI_MODE_NOTE,
};

struct midi_cfg {
	enum midi_mode mode;
	u8						 channel;
	union {
		enum midi_cc cc;
		u8					 raw;
	};
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */

int midi_init(void);
int midi_update(void);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/virtmap/virtmap.h
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"
#include "protocol/protocol.h"
#include "led/rgb.h"
#include "led/color.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum virtmap_mode {
	/**
	 * @brief A single vmap is active at one time.
	 * The user can toggle between vmaps using a switch/command.
	 * Note that the encoder range will now map directly to the virtmap range.
	 */
	VIRTMAP_MODE_TOGGLE,

	/**
	 * @brief All vmaps are active at the same time.
	 */
	VIRTMAP_MODE_OVERLAY,

	VIRTMAP_MODE_NB,
};

enum virtmap_display_mode {
	VIRTMAP_DISPLAY_SINGLE,
	VIRTMAP_DISPLAY_OVERLAY,

	VIRTMAP_DISPLAY_NB,
};

struct virtmap {
	/**
	 * @brief The lower and upper range determine the numerical values that will
	 * be generated by the virtual encoder as it is rotated.
	 *
	 * E.g if the lower value is 1000 and the upper value is 5000, then the
	 * virtual encoder will output the value 1000 at the position.start point
	 * (see position struct below) and the value 5000 at the position.stop
	 * point.
	 *
	 * Every intermediate point is linearly interpolated, so halfway between
	 * start and stop would output a value of 3000 in this  example.
	 *
	 * Note that if the lower value is greater than the upper value then
	 * the generated values will be in reverse order, i.e the output
	 * will start at 5000 and reduce as the encoder is rotated clockwise.
	 *
	 * Note that the upper and lower values should be within the range
	 * defined for the protocol to be used. For example, if the protocol is
	 * configured for midi CC then there is no point in using a range above
	 * 127 or below 0.
	 */
	struct {
		i8 lower;
		i8 upper;
	} range;

	/**
	 * @brief The start and stop position are the absolute values determining
	 * where the virtual encoder begins and ends on the physical encoder
	 * rotation. E.g if the start value is 0% and the stop value is 50% then the
	 * virtual encoder will only operate from 0 degrees to 180 degrees
	 * (midpoint) of the physical encoder.
	 *
	 * Note that the start and stop values are not percentages, they are a
	 * 8-bit value. To calculate percentages use the appropriate defines for
	 * min/max encoder value.
	 */
	struct {
		u8 start;
		u8 stop;
	} position;

	u8							 curr_pos;
	i16							 curr_val;
	struct proto_cfg cfg;

	// Color properties
	struct hsv_color hsv; // HSV color values for RGB LEDs

	struct rgb_8 rgb;
	struct rb_8	 rb;
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/hal/boot.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief Function called before main(), can be used as a trampoline to jump
 * execution to user defined address (such as the bootloader).
 */
void bootloader_check(void) __attribute__((used, naked, section(".init3")));

/**
 * @brief Restarts the AVR and enters the bootloader.
 */
void bootloader_start(void);
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/hal/sys.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2025) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#ifndef HAL_AVR_XMEGA_128A4U_SYS_H
#define HAL_AVR_XMEGA_128A4U_SYS_H

#include <avr/io.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Performs a software reset of the microcontroller.
 *
 * This function uses the Watchdog Timer (WDT) to trigger a system reset.
 * It disables interrupts, configures the WDT for the shortest timeout,
 * enables the WDT, and then enters an infinite loop until the WDT resets
 * the device.
 *
 * @note This function does not return.
 */
__attribute__((noreturn)) void hal_system_reset(void);

#ifdef __cplusplus
}
#endif

#endif // HAL_AVR_XMEGA_128A4U_SYS_H
// filepath: ./include/hal/adc.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2025) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/**
 * @file adc.h
 * @brief ADC driver header for XMEGA128A4U
 */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#include <stdint.h>
#include <stdbool.h>
#include <avr/io.h>

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief ADC channels available
 */
typedef enum {
	ADC_CH0 = 0,
	ADC_CH1,
	ADC_CH2,
	ADC_CH3
} adc_channel_t;

/**
 * @brief ADC reference voltage selection
 */
typedef enum {
	ADC_REF_INT1V		= ADC_REFSEL_INT1V_gc,	/**< Internal 1V reference */
	ADC_REF_INTVCC	= ADC_REFSEL_INTVCC_gc, /**< Internal VCC/1.6 reference */
	ADC_REF_AREFA		= ADC_REFSEL_AREFA_gc,	/**< External reference on PORTA */
	ADC_REF_AREFB		= ADC_REFSEL_AREFB_gc,	/**< External reference on PORTB */
	ADC_REF_INTVCC2 = ADC_REFSEL_INTVCC2_gc /**< Internal VCC/2 reference */
} adc_reference_t;

/**
 * @brief ADC result resolution
 */
typedef enum {
	ADC_RES_12BIT = ADC_RESOLUTION_12BIT_gc, /**< 12-bit right-adjusted result */
	ADC_RES_8BIT	= ADC_RESOLUTION_8BIT_gc,	 /**< 8-bit right-adjusted result */
	ADC_RES_LEFT12BIT =
			ADC_RESOLUTION_LEFT12BIT_gc /**< 12-bit left-adjusted result */
} adc_resolution_t;

/**
 * @brief ADC clock prescaler
 */
typedef enum {
	ADC_PRESCALER_DIV4	 = ADC_PRESCALER_DIV4_gc,		/**< Divide clock by 4 */
	ADC_PRESCALER_DIV8	 = ADC_PRESCALER_DIV8_gc,		/**< Divide clock by 8 */
	ADC_PRESCALER_DIV16	 = ADC_PRESCALER_DIV16_gc,	/**< Divide clock by 16 */
	ADC_PRESCALER_DIV32	 = ADC_PRESCALER_DIV32_gc,	/**< Divide clock by 32 */
	ADC_PRESCALER_DIV64	 = ADC_PRESCALER_DIV64_gc,	/**< Divide clock by 64 */
	ADC_PRESCALER_DIV128 = ADC_PRESCALER_DIV128_gc, /**< Divide clock by 128 */
	ADC_PRESCALER_DIV256 = ADC_PRESCALER_DIV256_gc, /**< Divide clock by 256 */
	ADC_PRESCALER_DIV512 = ADC_PRESCALER_DIV512_gc	/**< Divide clock by 512 */
} adc_prescaler_t;

/**
 * @brief ADC channel input mode
 */
typedef enum {
	ADC_CH_INPUTMODE_INTERNAL =
			ADC_CH_INPUTMODE_INTERNAL_gc, /**< Internal inputs, no gain */
	ADC_CH_INPUTMODE_SINGLEENDED =
			ADC_CH_INPUTMODE_SINGLEENDED_gc, /**< Single-ended input, no gain */
	ADC_CH_INPUTMODE_DIFF =
			ADC_CH_INPUTMODE_DIFF_gc, /**< Differential input, no gain */
	ADC_CH_INPUTMODE_DIFFWGAIN =
			ADC_CH_INPUTMODE_DIFFWGAIN_gc /**< Differential input, with gain */
} adc_ch_input_mode_t;

/**
 * @brief ADC channel gain values
 */
typedef enum {
	ADC_CH_GAIN_1X	 = ADC_CH_GAIN_1X_gc,	 /**< 1x gain */
	ADC_CH_GAIN_2X	 = ADC_CH_GAIN_2X_gc,	 /**< 2x gain */
	ADC_CH_GAIN_4X	 = ADC_CH_GAIN_4X_gc,	 /**< 4x gain */
	ADC_CH_GAIN_8X	 = ADC_CH_GAIN_8X_gc,	 /**< 8x gain */
	ADC_CH_GAIN_16X	 = ADC_CH_GAIN_16X_gc, /**< 16x gain */
	ADC_CH_GAIN_32X	 = ADC_CH_GAIN_32X_gc, /**< 32x gain */
	ADC_CH_GAIN_64X	 = ADC_CH_GAIN_64X_gc, /**< 64x gain */
	ADC_CH_GAIN_DIV2 = ADC_CH_GAIN_DIV2_gc /**< x/2 gain */
} adc_ch_gain_t;

/**
 * @brief ADC internal input selection
 */
typedef enum {
	ADC_CH_MUXINT_TEMP		= ADC_CH_MUXINT_TEMP_gc, /**< Temperature reference */
	ADC_CH_MUXINT_BANDGAP = ADC_CH_MUXINT_BANDGAP_gc, /**< Bandgap reference */
	ADC_CH_MUXINT_SCALEDVCC =
			ADC_CH_MUXINT_SCALEDVCC_gc,					 /**< VCC scaled down by 10 */
	ADC_CH_MUXINT_DAC = ADC_CH_MUXINT_DAC_gc /**< DAC output */
} adc_ch_internal_input_t;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/**
 * @brief Initialize the ADC module
 *
 * @param reference The reference to use for ADC measurements
 * @param resolution The resolution mode for ADC results
 * @param prescaler The clock prescaler value
 */
void adc_init(adc_reference_t reference, adc_resolution_t resolution,
							adc_prescaler_t prescaler);

/**
 * @brief Configure an ADC channel for external input
 *
 * @param ch The ADC channel to configure
 * @param input_mode The input mode to use
 * @param gain The gain to apply (only used when input_mode is DIFFWGAIN)
 * @param positive_input The positive input pin selection
 */
void adc_channel_config(adc_channel_t ch, adc_ch_input_mode_t input_mode,
												adc_ch_gain_t gain, uint8_t positive_input);

/**
 * @brief Configure an ADC channel for internal inputs
 *
 * @param ch The ADC channel to configure
 * @param input The internal input to select
 */
void adc_channel_config_internal(adc_channel_t					 ch,
																 adc_ch_internal_input_t input);

/**
 * @brief Start a conversion on an ADC channel
 *
 * @param ch The ADC channel on which to start a conversion
 */
void adc_start_conversion(adc_channel_t ch);

/**
 * @brief Check if a conversion is complete on an ADC channel
 *
 * @param ch The ADC channel to check
 * @return true if the conversion is complete, false otherwise
 */
bool adc_is_conversion_complete(adc_channel_t ch);

/**
 * @brief Read the result of a conversion on an ADC channel
 *
 * @param ch The ADC channel to read from
 * @return The conversion result
 */
uint16_t adc_read_result(adc_channel_t ch);

/**
 * @brief Perform a single conversion and return the result
 *
 * @param ch The ADC channel on which to perform the conversion
 * @return The conversion result
 */
uint16_t adc_get_sample(adc_channel_t ch);

/**
 * @brief Read the internal temperature sensor and convert to degrees Celsius
 *
 * @return Temperature in degrees Celsius
 */
int16_t adc_read_temperature(void);

/**
 * @brief Read the internal temperature sensor and convert to degrees Celsius
 * with decimal precision
 *
 * @return Temperature in degrees Celsius as a floating-point value
 */
float adc_read_temperature_float(void);

/**
 * @brief Enable the ADC
 */
void adc_enable(void);

/**
 * @brief Disable the ADC
 */
void adc_disable(void);
// filepath: ./include/hal/timer.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <avr/io.h>

#include "system/types.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum timer_peripheral {
	TIMER_TCC0,
	TIMER_TCC1,
	TIMER_TCC2,
	TIMER_TCD0,
	TIMER_TCD1,
	TIMER_TCD2,
	TIMER_TCE0,

	TIMER_NB,
};

enum timer_channel {
	TIMER_CHANNEL_A, // PWM on pin 0
	TIMER_CHANNEL_B, // PWM on pin 1
	TIMER_CHANNEL_C, // PWM on pin 2
	TIMER_CHANNEL_D, // PWM on pin 3

	TIMER_CHANNEL_NB,
};

enum timer_mode {
	TIMER_MODE_OVF,
	TIMER_MODE_PWM,

	TIMER_MODE_NB,
};

struct pwm_config {
	u16 freq; // Desired PWM frequency
	u8	duty; // Desired duty cycle percentage (0 to 100)
};

struct timer_config {
	volatile TC0_t*				timer;
	enum timer_peripheral periph;
	enum timer_channel		channel;
	u32										freq; // Timer frequency (Hz)

	enum timer_mode mode;
	union {
		struct pwm_config pwm;
	};
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

int timer_init(struct timer_config* cfg);
u16 timer_getval(struct timer_config* cfg);

void timer_ch_isr_enable(struct timer_config* cfg, enum isr_priority priority);
void timer_ch_isr_disable(struct timer_config* cfg);
void timer_ovr_isr_enable(struct timer_config* cfg, enum isr_priority priority);
void timer_ovr_isr_disable(struct timer_config* cfg);

void timer_pwm_start(struct timer_config* cfg);
void timer_pwm_stop(struct timer_config* cfg);
void timer_pwm_set_duty(struct timer_config* cfg, u8 duty);
void timer_get_parameters(unsigned int freq, TC_CLKSEL_t* clk_sel, u16* period);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/hal/usart.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <avr/io.h>
#include "system/types.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

// enum uart_module {
//   UART_MODULE_C0,
//   UART_MODULE_C1,
//   UART_MODULE_D0,
//   UART_MODULE_D1,
//   UART_MODULE_E0,

//   UART_MODULE_NB,
// };

enum spi_mode {
	SPI_MODE_CLK_LO_PHA_LO,
	SPI_MODE_CLK_LO_PHA_HI,
	SPI_MODE_CLK_HI_PHA_LO,
	SPI_MODE_CLK_HI_PHA_HI,

	SPI_MODE_NB,
};

struct usart_config {
	enum spi_mode mode;
	u32						baudrate;
	enum endian		endian;
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief Initialise a USART peripheral (such as USARTC0) in Master SPI Mode
 * IMPORTANT!! Only call this after the CPU clock is configured to run at F_CPU.
 * Does not start UART tx/rx.
 * GPIO will be configured based on the port and PORT.REMAP
 *
 * Default pinout is:
 * Pin 1 - SCK
 * Pin 2 - RX
 * Pin 3 - TX
 *
 * Remapped pinout is:
 * Pin 5 - SCK
 * Pin 6 - RX
 * Pin 7 - TX
 *
 * @param config A pointer to a USART config.
 */
void usart_module_init(USART_t* usart, const struct usart_config* config);

// Enable or disable USART module transmission.
void usart_set_tx(USART_t* usart, bool enable);

// Enable or disable UART module receive.
void usart_set_rx(USART_t* usart, bool enable);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/hal/init.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

void avr_xmega128a4u_init(void);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/hal/dma.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <avr/io.h>
#include "system/types.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

struct dma_channel_cfg {
	u8									repeat_count; // 1 for single shot mode, 0 = infinite
	u16									block_size;		// bytes per block
	DMA_CH_BURSTLEN_t		burst_len;
	DMA_CH_TRIGSRC_t		trig_source;
	DMA_DBUFMODE_t			dbuf_mode;
	enum isr_priority		int_prio;
	enum isr_priority		err_prio;
	uptr								src_ptr;
	DMA_CH_SRCDIR_t			src_addr_mode;
	DMA_CH_SRCRELOAD_t	src_reload_mode;
	uptr								dst_ptr;
	DMA_CH_DESTDIR_t		dst_addr_mode;
	DMA_CH_DESTRELOAD_t dst_reload_mode;
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief Initialise the DMA peripheral - call once during system startup.
 */
void dma_peripheral_init(void);

/**
 * @brief Initialise a specific DMA channel.
 *
 * @param ch Pointer to DMA_ch_t avr-libc struct.
 * @param cfg Channel configuration.
 * @return int 0 on success.
 *
 * @warning Disables interrupts during configuration.
 */
int dma_channel_init(DMA_CH_t* ch, struct dma_channel_cfg* cfg);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/hal/signature.h
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2025) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <avr/io.h> // For NVM_PROD_SIGNATURES_t

/**
 * @brief Reads the production signature row from NVM into the provided struct.
 *
 * @param prod_sig Pointer to the destination NVM_PROD_SIGNATURES_t structure.
 */
void signature_read(NVM_PROD_SIGNATURES_t* prod_sig);
// filepath: ./include/hal/gpio.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <avr/io.h>

#include "system/types.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum gpio_dir {
	GPIO_INPUT,
	GPIO_OUTPUT
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

void gpio_mode(PORT_t* port, u8 pin, PORT_OPC_t mode);
void gpio_dir(PORT_t* port, u8 pin, enum gpio_dir dir);
void gpio_set(PORT_t* port, u8 pin, u8 state);
u8	 gpio_get(PORT_t* port, u8 pin);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/event/sys.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"
#include "event/event.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

extern struct event_channel sys_event_ch;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum events_core {
	EVT_SYS_REQ_CFG_RESET,
	EVT_SYS_RES_CFG_RESET,

	EVT_SYS_REQ_CFG_LOAD,
	EVT_SYS_RES_CFG_LOAD,

	EVT_SYS_REQ_CFG_SAVE,
	EVT_SYS_RES_CFG_SAVE,

	EVT_SYS_MENU_STARTING,
	EVT_SYS_MENU_STOPPING,

	EVT_SYS_NB,
};

struct sys_event {
	u8 type;
	union {
		void*						 ptr;
		enum return_code ret;
	} data;
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/event/event.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"
#include "system/utility.h"
#include "system/error.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief Macro to declare a static event handler.
 *
 * @param p Priority (0-255).
 * @param n Name of the structure
 * @param h Pointer to handler function.
 */
#define EVT_HANDLER(p, n, h)                                                   \
	static struct event_ch_handler n = {                                         \
			.priority = p,                                                           \
			.handler	= h,                                                           \
			.next			= NULL,                                                        \
	}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum event_ch {
	EVENT_CHANNEL_SYS,			// Reserved for system events
	EVENT_CHANNEL_IO,				// IO events
	EVENT_CHANNEL_MIDI_IN,	// MIDI events (rx)
	EVENT_CHANNEL_MIDI_OUT, // MIDI events (tx)

	EVENT_CHANNEL_NB,
};

/**
 * @brief
 * Priority determines the order in which handlers are called.
 * 0 means the handlers are called in the order they were registered.
 * 1 means max priority, and will be called first.
 * 255 means min priority, and will be called last.
 *
 * Most of the time 0 priority is fine.
 * Events that must be handled sychronously (realtime priority) can
 * be posted with the event_post_rt() function - this will block
 * and call each handler in turn immediately.
 */
struct event_ch_handler {
	u8 priority;
	int (*handler)(void* event);
	struct event_ch_handler* next;
};

/**
 * @brief Event channel structure.
 * The queue parameter is a pointer to a statically allocated buffer.
 * The buffer size is upto the user, if there are few events then
 * a small buffer is fine. Larger queues increase the latency of
 * events being handled when many events are posted.
 *
 * The handlers parameter is a linked-list of event handlers for this channel.
 *
 * If only one handler is required for all events in the channel then
 * the onehandler parameter can be set to true.
 *
 * The size parameter is the size of the queue buffer.
 *
 * The head parameter is the index of the next event to be handled.
 * It is private and should not be modified by the user.
 */
struct event_channel {
	u8*				 queue;			 // Statically allocated queue buffer
	const uint queue_size; // The size of the array (number of messages)
	const uint data_size;	 // Size of data for a single event (for memcpy)
	struct event_ch_handler* handlers; // Link list of handlers
	bool onehandler; // Set true if handlers is a single handler for all events
	uint head;			 // (private)
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief Initialise the event-handling system.
 *
 * @return int General error code.
 */
int event_init(void);

/**
 * @brief Processes all queued events in all event channels.
 * Event handlers for each event are called in priority order.
 *
 * @return int General error code.
 */
int event_update(void);

/**
 * @brief Registers a new event channel.
 * @warning The event channel must have an associated enum
 * assigned - see enum event_ch.
 *
 * @param ch The enum for the event channel.
 * @param def Pointer to the channel definition.
 *
 * @return int General error code.
 * @retval ERR_DUPLICATE if enum value is not unique.
 * @retval ERR_BAD_PARAM if channel definition is incorrect.
 * @retval 0 on success.
 */
int event_channel_register(enum event_ch ch, struct event_channel* def);

/**
 * @brief Processes all events for a single channel.
 * Normally there will be no need to do this, but it is available
 * if required.
 *
 * @param ch Enum of the event channel.
 * @return int General error code.
 */
int event_channel_process(enum event_ch ch);

/**
 * @brief Subscribe (assign) a new event handler to an existing event channel.
 *
 * @param ch Enum of the event channel.
 * @param new_handler Pointer to the new event handler.
 *
 * @return int General error code.
 * @retval ERR_UNSUPPORTED cannot assign a new handler to this event channel.
 * @retval 0 on success.
 */
int event_channel_subscribe(enum event_ch						 ch,
														struct event_ch_handler* new_handler);

/**
 * @brief Unsubscribe an event handler from an existing event channel.
 *
 * @param ch Enum of the event channel.
 * @param h Pointer to the existing event handler.
 * @return int General error code.
 * @retval 0 on success.
 */
int event_channel_unsubscribe(enum event_ch ch, struct event_ch_handler* h);

/**
 * @brief Post an event to an event queue.
 * The event will be handled later when the event_update function
 * is called as part of the main system loop.
 *
 * This function copies the event object into the queue, the
 * original object can be safely freed (if on the heap).
 *
 * @param ch Enum of the event channel.
 * @param event Pointer to the event.
 * @return int General error code.
 * @retval ERR_NO_MEM queue is full - cannot add a new event.
 * @retval 0 on success.
 */
int event_post(enum event_ch ch, void* event);

/**
 * @brief Process an event immediately (real-time)
 *
 * @param ch Enum of the event channel.
 * @param event Pointer to the event.
 * @return int General error code.
 * @retval 0 on success.
 */
int event_post_rt(enum event_ch ch, void* event);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/event/midi.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"
#include "event/event.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define MIDI_SYSEX_OUT_DATA_LEN_MAX 8

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

extern struct event_channel midi_in_event_ch;
extern struct event_channel midi_out_event_ch;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum midi_event {
	MIDI_EVENT_CC,
	MIDI_EVENT_SYSEX,

	MIDI_EVENT_NB,
};

enum midi_sysex_type {
	SYSEX_TYPE_1BYTE,
	SYSEX_TYPE_END_1BYTE = SYSEX_TYPE_1BYTE,
	SYSEX_TYPE_2BYTE,
	SYSEX_TYPE_3BYTE,
	SYSEX_TYPE_START_3BYTE,
	SYSEX_TYPE_END_2BYTE,
	SYSEX_TYPE_END_3BYTE,

	SYSEX_TYPE_NB,

	SYSEX_TYPE_INVALID = 0xFF,
};

typedef struct __attribute__((packed)) {
	u8 channel;
	u8 control;
	u8 value;
} midi_cc_event_s;

typedef struct __attribute__((packed)) {
	u8 type; // enum midi_sysex_type
	u8 data[3];
} midi_sysex_in_event_s;

typedef struct __attribute__((packed)) {
	u8 cmd;
	u8 param;
	u8 data_len;
	u8 data[MIDI_SYSEX_OUT_DATA_LEN_MAX];
} midi_sysex_out_event_s;

typedef struct __attribute__((packed)) {
	u8 type;
	union {
		midi_cc_event_s				 cc;
		midi_sysex_in_event_s	 sysex_in;
		midi_sysex_out_event_s sysex_out;
	} data;
} midi_event_s;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./include/event/io.h
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#pragma once
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"
#include "io/quadrature.h"
#include "io/switch.h"
#include "event/event.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

extern struct event_channel io_event_ch;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum events_io {
	EVT_IO_ENCODER_ROTATION,
	EVT_IO_ENCODER_SWITCH,
	EVT_IO_BUTTON,

	EVT_IO_NB,
};

struct io_event {
	u8		type;
	void* ctx;
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./midi/midi_lufa.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"
#include "system/error.h"
#include "system/print.h"
#include "event/midi.h"
#include "midi/midi.h"
#include "usb/usb_lufa.h"

#include "LUFA/Common/Common.h"
#include "LUFA/Drivers/USB/USB.h"
#include "LUFA/Drivers/USB/Class/Common/MIDIClassCommon.h"
#include "LUFA/Drivers/USB/Class/Device/MIDIClassDevice.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define MIDI_EVENT_QUEUE_SIZE 16

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

static int									midi_out_handler(void* event);
static enum midi_sysex_type midi_sysex_type(u8 evt);
static int									lufa_transmit(u8* data, u8 len);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */

USB_ClassInfo_MIDI_Device_t lufa_usb_midi_device = {
		.Config =
				{
						.DataINEndpoint =
								{
										.Address = (USB_EP_MIDI_STREAM_IN | ENDPOINT_DIR_IN),
										.Size		 = USB_MIDI_STREAM_EPSIZE,
										.Banks	 = 1,
								},
						.DataOUTEndpoint =
								{
										.Address = (USB_EP_MIDI_STREAM_OUT | ENDPOINT_DIR_OUT),
										.Size		 = USB_MIDI_STREAM_EPSIZE,
										.Banks	 = 1,
								},
				},
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */

static midi_event_s midi_in_event_queue[MIDI_EVENT_QUEUE_SIZE];
static midi_event_s midi_out_event_queue[MIDI_EVENT_QUEUE_SIZE];

static struct event_ch_handler midi_out_event_handler = {
		.handler	= midi_out_handler,
		.next			= NULL,
		.priority = 0,
};

struct event_channel midi_in_event_ch = {
		.queue			= (u8*)midi_in_event_queue,
		.queue_size = MIDI_EVENT_QUEUE_SIZE,
		.data_size	= sizeof(midi_event_s),
		.handlers		= NULL,
		.onehandler = false,
};

struct event_channel midi_out_event_ch = {
		.queue			= (u8*)midi_out_event_queue,
		.queue_size = MIDI_EVENT_QUEUE_SIZE,
		.data_size	= sizeof(midi_event_s),
		.handlers		= NULL,
		.onehandler = false,
};

// Transmit buffer for USB MIDI packets (must 4 bytes, do not change!)
static u8 tx_buf[4];

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

int midi_init(void) {
	int ret = event_channel_register(EVENT_CHANNEL_MIDI_IN, &midi_in_event_ch);
	RETURN_ON_ERR(ret);

	ret = event_channel_register(EVENT_CHANNEL_MIDI_OUT, &midi_out_event_ch);
	RETURN_ON_ERR(ret);

	ret =
			event_channel_subscribe(EVENT_CHANNEL_MIDI_OUT, &midi_out_event_handler);
	RETURN_ON_ERR(ret);

	return ret;
}

int midi_update(void) {
	MIDI_EventPacket_t rx;

	while (MIDI_Device_ReceiveEventPacket(&lufa_usb_midi_device, &rx)) {

		switch (rx.Event) {
			case MIDI_EVENT(0, MIDI_COMMAND_CONTROL_CHANGE): {
				// println_pmem("Rx CC:");
				midi_cc_event_s cc;
				cc.channel = (rx.Data1 & 0x0F);
				cc.control = rx.Data2;
				cc.value	 = rx.Data3;

				midi_event_s e;
				e.type		= MIDI_EVENT_CC;
				e.data.cc = cc;

#ifdef ENABLE_CONSOLE
#warning "Clib printf functions use lots of memory."
				// char										 buf[64];
				// static const char* const formatstr = "CH: %u, CC: %u, VAL:
				// %u"; sprintf(buf, formatstr, cc.channel, cc.control,
				// cc.value); println(buf);
#endif

				event_post(EVENT_CHANNEL_MIDI_IN, &e);
				break;
			}

			case MIDI_EVENT(0, MIDI_COMMAND_SYSEX_1BYTE):
			case MIDI_EVENT(0, MIDI_COMMAND_SYSEX_2BYTE):
			case MIDI_EVENT(0, MIDI_COMMAND_SYSEX_3BYTE):
			case MIDI_EVENT(0, MIDI_COMMAND_SYSEX_START_3BYTE): //  >= 4 bytes
			case MIDI_EVENT(0, MIDI_COMMAND_SYSEX_END_2BYTE):
			case MIDI_EVENT(0, MIDI_COMMAND_SYSEX_END_3BYTE): {
				midi_event_s e = {
						.type = MIDI_EVENT_SYSEX,
						.data.sysex_in =
								{
										.type = midi_sysex_type(rx.Event),
										.data = {rx.Data1, rx.Data2, rx.Data3},
								},
				};

				event_post(EVENT_CHANNEL_MIDI_IN, &e);

				// transmit back to host
				// MIDI_Device_SendEventPacket(&lufa_usb_midi_device, &rx);
				break;
			}

			default: return 0;
		}
	}

	return 0;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */

static int midi_out_handler(void* event) {
	assert(event);

	midi_event_s* e = (midi_event_s*)event;

	MIDI_EventPacket_t pkt = {0};

	switch (e->type) {
		case MIDI_EVENT_CC: {
			midi_cc_event_s* cc = &e->data.cc;
			// println_pmem("Tx CC:");

			pkt.Event = MIDI_EVENT(0, MIDI_COMMAND_CONTROL_CHANGE);
			pkt.Data1 = ((cc->channel & 0x0F) | MIDI_COMMAND_CONTROL_CHANGE);
			pkt.Data2 = (cc->control & 0x7F);
			pkt.Data3 = (cc->value & 0x7F);

			MIDI_Device_SendEventPacket(&lufa_usb_midi_device, &pkt);
			break;
		}

		case MIDI_EVENT_SYSEX: {
			midi_sysex_out_event_s* sysex = &e->data.sysex_out;

			tx_buf[0] = MIDI_EVENT(0, MIDI_COMMAND_SYSEX_START_3BYTE);
			tx_buf[1] = MIDI_STATUS_SYSTEM_EXCLUSIVE;
			tx_buf[2] = MIDI_MFR_ID_1;
			tx_buf[3] = MIDI_MFR_ID_2;
			lufa_transmit(tx_buf, sizeof(tx_buf));

			tx_buf[0] = MIDI_EVENT(0, MIDI_COMMAND_SYSEX_START_3BYTE);
			tx_buf[1] = MIDI_MFR_ID_3;
			tx_buf[2] = sysex->cmd;
			tx_buf[3] = sysex->param;
			lufa_transmit(tx_buf, sizeof(tx_buf));

			u8	 remaining = sysex->data_len;
			u8*	 payload	 = sysex->data;
			bool done			 = false;

			switch (sysex->data_len) {
				case 0: {
					tx_buf[0] = MIDI_EVENT(0, MIDI_COMMAND_SYSEX_END_1BYTE);
					tx_buf[1] = MIDI_STATUS_END_OF_EXCLUSIVE;
					tx_buf[2] = 0;
					tx_buf[3] = 0;
					done			= true;
					break;
				}

				case 1: {
					tx_buf[0] = MIDI_EVENT(0, MIDI_COMMAND_SYSEX_END_3BYTE);
					tx_buf[1] = sysex->data_len;
					tx_buf[2] = *payload;
					tx_buf[3] = MIDI_STATUS_END_OF_EXCLUSIVE;
					done			= true;
					break;
				}

				default:
				case 2: {
					tx_buf[0] = MIDI_EVENT(0, MIDI_COMMAND_SYSEX_START_3BYTE);
					tx_buf[1] = sysex->data_len;
					tx_buf[2] = *payload++;
					tx_buf[3] = *payload++;
					break;
				}
			}

			lufa_transmit(tx_buf, sizeof(tx_buf));

			while (!done) {
				memset(tx_buf, 0, sizeof(tx_buf));
				switch (remaining) {
					case 0: {
						tx_buf[0] = MIDI_EVENT(0, MIDI_COMMAND_SYSEX_END_1BYTE);
						tx_buf[1] = MIDI_STATUS_END_OF_EXCLUSIVE;
						done			= true;
						remaining = 0;
						break;
					}

					case 1: {
						tx_buf[0] = MIDI_EVENT(0, MIDI_COMMAND_SYSEX_END_2BYTE);
						tx_buf[1] = sysex->data[*payload++];
						tx_buf[2] = MIDI_STATUS_END_OF_EXCLUSIVE;
						done			= true;
						remaining = 0;
						break;
					}

					case 2: {
						tx_buf[0] = MIDI_EVENT(0, MIDI_COMMAND_SYSEX_END_3BYTE);
						tx_buf[1] = sysex->data[*payload++];
						tx_buf[2] = sysex->data[*payload++];
						tx_buf[3] = MIDI_STATUS_END_OF_EXCLUSIVE;
						done			= true;
						remaining = 0;
						break;
					}

					default:
					case 3: {
						tx_buf[0] = MIDI_EVENT(0, MIDI_COMMAND_SYSEX_START_3BYTE);
						tx_buf[1] = sysex->data[*payload++];
						tx_buf[2] = sysex->data[*payload++];
						tx_buf[3] = sysex->data[*payload++];
						remaining -= 3;
						break;
					}
						lufa_transmit(tx_buf, sizeof(tx_buf));
				}
			}

			break;
		}

		default: {
			return ERR_BAD_PARAM;
		}
	}

	// printbuf(&pkt.Data1, 1);
	// printbuf(&pkt.Data2, 1);
	// printbuf(&pkt.Data3, 1);

	return 0;
}

static enum midi_sysex_type midi_sysex_type(u8 evt) {
	switch (evt) {
		case MIDI_EVENT(0, MIDI_COMMAND_SYSEX_1BYTE): return SYSEX_TYPE_1BYTE;
		case MIDI_EVENT(0, MIDI_COMMAND_SYSEX_2BYTE): return SYSEX_TYPE_2BYTE;
		case MIDI_EVENT(0, MIDI_COMMAND_SYSEX_3BYTE): return SYSEX_TYPE_3BYTE;
		case MIDI_EVENT(0, MIDI_COMMAND_SYSEX_START_3BYTE):
			return SYSEX_TYPE_START_3BYTE;
		case MIDI_EVENT(0, MIDI_COMMAND_SYSEX_END_2BYTE):
			return SYSEX_TYPE_END_2BYTE;
		case MIDI_EVENT(0, MIDI_COMMAND_SYSEX_END_3BYTE):
			return SYSEX_TYPE_END_3BYTE;
		default: return SYSEX_TYPE_INVALID;
	}
}

static int lufa_transmit(u8* data, u8 len) {
	if (USB_DeviceState != DEVICE_STATE_Configured)
		return ENDPOINT_RWSTREAM_DeviceDisconnected;

	uint8_t ErrorCode;

	Endpoint_SelectEndpoint(lufa_usb_midi_device.Config.DataINEndpoint.Address);

	if ((ErrorCode = Endpoint_Write_Stream_LE(data, len, NULL)) !=
			ENDPOINT_RWSTREAM_NoError)
		return ErrorCode;

	if (!(Endpoint_IsReadWriteAllowed()))
		Endpoint_ClearIN();

	return MIDI_Device_Flush(&lufa_usb_midi_device);
}
// filepath: ./midi/sysex.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <string.h>

#include "midi/sysex.h"
#include "event/midi.h"

// Test sequence:
// [sysex start] [mfid] [cmd] [param] [data] [sysex end]
// 1 byte        3 bytes 1 byte 1 byte  1 byte  1 byte
// Test sequence to disable detent for enc[0][0] is:
// f0 53 41 4d 02 00 00 00 00 f7
// [header] 	 	[set] [param] [bank_idx] [enc_idx] [val] [footer]
// f0 53 41 4d   02    00     00  				00 				00 			f7
// Test sequence to enable detent for enc[0][0] is:
// f0 53 41 4d 02 00 00 00 01 f7

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

enum stream_state {
	STREAM_IDLE,
	STREAM_RECEIVING,
	STREAM_COMPLETE,
	STREAM_ERROR,

	STREAM_NB,
};

struct sysex_type_streamer_def {
	u8								len_data;
	enum stream_state next_state;
};

struct sysex_item_data_info {
	size_t offset;
	size_t len;
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

static int midi_in_handler(void* evt);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */

EVT_HANDLER(2, evt_midi, midi_in_handler);

static u8 sysex_data_len[SYSEX_TYPE_NB] = {
		[SYSEX_TYPE_1BYTE] = 1,			[SYSEX_TYPE_2BYTE] = 2,
		[SYSEX_TYPE_3BYTE] = 3,			[SYSEX_TYPE_START_3BYTE] = 3,
		[SYSEX_TYPE_END_2BYTE] = 2, [SYSEX_TYPE_END_3BYTE] = 3,
};

static const enum stream_state sysex_next_state[SYSEX_TYPE_NB] = {
		[SYSEX_TYPE_1BYTE]			 = STREAM_COMPLETE,
		[SYSEX_TYPE_2BYTE]			 = STREAM_COMPLETE,
		[SYSEX_TYPE_3BYTE]			 = STREAM_COMPLETE,
		[SYSEX_TYPE_START_3BYTE] = STREAM_RECEIVING,
		[SYSEX_TYPE_END_2BYTE]	 = STREAM_COMPLETE,
		[SYSEX_TYPE_END_3BYTE]	 = STREAM_COMPLETE,
};

#define SYSEX_DATA_INFO(e, s, v) [e] = {offsetof(s, v), sizeof(((s*)0)->v)}

// clang-format off
static const struct sysex_item_data_info sysex_data_info[MF_SYSEX_PARAM_NB] = {
	SYSEX_DATA_INFO(MF_SYSEX_PARAM_ENCODER_DETENT, struct encoder, detent),
	SYSEX_DATA_INFO(MF_SYSEX_PARAM_ENCODER_DISPLAY_MODE, struct encoder, display.mode),
	SYSEX_DATA_INFO(MF_SYSEX_PARAM_ENCODER_VMAP_DISPLAY_MODE, struct encoder, display.virtmode),
	SYSEX_DATA_INFO(MF_SYSEX_PARAM_ENCODER_VMAP_MODE, struct encoder, vmap_mode),
	SYSEX_DATA_INFO(MF_SYSEX_PARAM_ENCODER_VMAP_ACTIVE, struct encoder, vmap_active),
	SYSEX_DATA_INFO(MF_SYSEX_PARAM_ENCODER_SWITCH_STATE, struct encoder, sw_state),
	SYSEX_DATA_INFO(MF_SYSEX_PARAM_ENCODER_SWITCH_MODE, struct encoder, sw_mode),
	SYSEX_DATA_INFO(MF_SYSEX_PARAM_ENCODER_SWITCH_PROTO, struct encoder, sw_cfg),
	SYSEX_DATA_INFO(MF_SYSEX_PARAM_VMAP_RANGE, struct virtmap, range),
	SYSEX_DATA_INFO(MF_SYSEX_PARAM_VMAP_POSITION, struct virtmap, position),
	SYSEX_DATA_INFO(MF_SYSEX_PARAM_VMAP_RGB, struct virtmap, rgb),
	SYSEX_DATA_INFO(MF_SYSEX_PARAM_VMAP_RB, struct virtmap, rb),
	SYSEX_DATA_INFO(MF_SYSEX_PARAM_VMAP_PROTO, struct virtmap, cfg),
	SYSEX_DATA_INFO(MF_SYSEX_PARAM_SIDE_SWITCH, struct mf_rt, curr_bank),
	SYSEX_DATA_INFO(MF_SYSEX_PARAM_ACTIVE_BANK, struct mf_rt, curr_bank),
};

// clang-format on

static enum stream_state stream_state = STREAM_IDLE;
// Buffer to stream incoming sysex, +2 for start and end sysex bytes
static u8								 buffer[MF_SYSEX_MAX_PKT_SIZE + 2];
static u8								 buffer_idx = 0;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

int mf_sysex_init(void) {
	event_channel_subscribe(EVENT_CHANNEL_MIDI_IN, &evt_midi);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */

static int midi_in_handler(void* evt) {
	int						ret	 = 0;
	midi_event_s* midi = (midi_event_s*)evt;

	if (midi->type != MIDI_EVENT_SYSEX) {
		return 0; // Ignore non-sysex events
	} else if (midi->data.sysex_in.type == SYSEX_TYPE_INVALID) {
		ret = ERR_BAD_PARAM;
		goto cleanup;
	}

	// Get the number of bytes in the sysex packet
	u8 len = sysex_data_len[midi->data.sysex_in.type];

	if (buffer_idx + len > MF_SYSEX_MAX_PKT_SIZE) {
		ret = ERR_NO_MEM;
		goto cleanup;
	}

	// Copy the sysex data into the streaming buffer
	for (int i = 0; i < len; i++) {
		buffer[buffer_idx++] = midi->data.sysex_in.data[i];
	}

	// Update the stream state based on the sysex message type
	stream_state = sysex_next_state[midi->data.sysex_in.type];

	if (stream_state != STREAM_COMPLETE) {
		return 0;
	}

	// If streaming is complete then we have a message in the buffer to process.
	const mf_sysex_msg_s* msg = (mf_sysex_msg_s*)&buffer[1];

	// Validate that the received data conforms
	// Check if the number of bytes received is too small
	if (buffer_idx < MF_SYSEX_MIN_PKT_SIZE) {
		ret = ERR_BAD_MSG;
		goto cleanup;
	}

	// Check the expected length based on the parameter enum data length
	u8 expected_len =
			MF_SYSEX_MIN_PKT_SIZE + sysex_data_info[msg->param_enum].len;

	switch (msg->param_enum) {}

	// Check if sysex start and end bytes are correct
	if (buffer[0] != MIDI_STATUS_SYSTEM_EXCLUSIVE ||
			buffer[buffer_idx - 1] != MIDI_STATUS_END_OF_EXCLUSIVE) {
		ret = ERR_BAD_MSG;
		goto cleanup;
	}

	// Validate the manufacturer ID is correct (SAM)
	if (msg->mf_id[0] != MIDI_MFR_ID_1 && msg->mf_id[1] != MIDI_MFR_ID_2 &&
			msg->mf_id[2] != MIDI_MFR_ID_3) {
		ret = ERR_BAD_MSG;
		goto cleanup;
	}

	// Check the command is valid
	if (msg->cmd != MF_SYSEX_GET && msg->cmd != MF_SYSEX_SET &&
			msg->cmd != MF_SYSEX_STOP) {
		ret = ERR_BAD_MSG;
		goto cleanup;
	}

	// Check the parameter is valid
	if (msg->param_enum >= MF_SYSEX_PARAM_NB) {
		ret = ERR_BAD_PARAM;
		goto cleanup;
	}

	switch (msg->param_enum) {
		case MF_SYSEX_PARAM_ENCODER_DETENT:
		case MF_SYSEX_PARAM_ENCODER_DISPLAY_MODE:
		case MF_SYSEX_PARAM_ENCODER_VMAP_DISPLAY_MODE:
		case MF_SYSEX_PARAM_ENCODER_VMAP_MODE:
		case MF_SYSEX_PARAM_ENCODER_VMAP_ACTIVE:
		case MF_SYSEX_PARAM_ENCODER_SWITCH_STATE:
		case MF_SYSEX_PARAM_ENCODER_SWITCH_MODE:
		case MF_SYSEX_PARAM_ENCODER_SWITCH_PROTO: {
			u8							bank		= msg->param.enc.bank_idx;
			u8							enc			= msg->param.enc.enc_idx;
			struct encoder* encoder = &gENCODERS[bank][enc];
			void*						param =
					(void*)((u8*)encoder + sysex_data_info[msg->param_enum].offset);
			memcpy(param, (const void*)&msg->param.enc.data,
						 sysex_data_info[msg->param_enum].len);
			break;
		}

		case MF_SYSEX_PARAM_VMAP_RANGE:
		case MF_SYSEX_PARAM_VMAP_POSITION:
		case MF_SYSEX_PARAM_VMAP_RGB:
		case MF_SYSEX_PARAM_VMAP_RB:
		case MF_SYSEX_PARAM_VMAP_PROTO: {
			u8							bank_idx = msg->param.vmap.bank_idx;
			u8							enc_idx	 = msg->param.vmap.enc_idx;
			u8							vmap_idx = msg->param.vmap.vmap_idx;
			struct virtmap* vmap		 = &gENCODERS[bank_idx][enc_idx].vmaps[vmap_idx];
			void*						param =
					(void*)((u8*)vmap + sysex_data_info[msg->param_enum].offset);
			memcpy(param, (const void*)&msg->param.vmap.data,
						 sysex_data_info[msg->param_enum].len);
			break;
		}

		case MF_SYSEX_PARAM_SIDE_SWITCH: {
			break;
		}

		case MF_SYSEX_PARAM_ACTIVE_BANK: {
			break;
		}

		default: {
			ret = ERR_BAD_PARAM;
		}
	}

	if (ret != 0) {
		goto cleanup;
	}

	switch (msg->cmd) {
		case MF_SYSEX_GET: {
			midi_event_s reply = {
					.type = MIDI_EVENT_SYSEX,
					.data.sysex_out =
							{
									.cmd			= MF_SYSEX_GET_RESPONSE,
									.param		= msg->param_enum,
									.data_len = 1,
									.data			= ret,
							},
			};
			event_post(EVENT_CHANNEL_MIDI_OUT, &reply);
			break;
		}

		case MF_SYSEX_SET: {
			midi_event_s reply = {
					.type = MIDI_EVENT_SYSEX,
					.data.sysex_out =
							{
									.cmd			= MF_SYSEX_SET_RESPONSE,
									.param		= msg->param_enum,
									.data_len = 1,
									.data			= ret,
							},
			};
			event_post(EVENT_CHANNEL_MIDI_OUT, &reply);
			break;
		}

		default: {
			ret = ERR_BAD_MSG;
			goto cleanup;
		}
	}

cleanup:
	buffer_idx = 0;
	memset(buffer, 0, sizeof(buffer));
	stream_state = STREAM_IDLE;
	return ret;
}
// filepath: ./config/config.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2024) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <string.h>
#include <avr/eeprom.h>

#include "event/event.h"
#include "event/sys.h"
#include "system/error.h"
#include "system/hardware.h"
#include "system/time.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define EE_VERSION (u16)(11)

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

// Data structure for eeprom storage using EEMEM flag

struct eeprom_midi_cfg {
	u8 channel : 4;
	u8 mode		 : 4;

	union {
		u8 cc;
		u8 raw;
	};
};

typedef union {
	u8										 type;
	struct eeprom_midi_cfg midi;
} eeprom_proto_cfg_s;

struct eeprom_virtmap_cfg {
	struct {
		i8 lower;
		i8 upper;
	} range;

	struct {
		u8 start;
		u8 stop;
	} position;
};

struct eeprom_encoder {
	// General
	u8 display_mode : 2;
	u8 virtmap_mode : 1;

	// Encoder
	u8 detent				: 1;
	u8 vmap_mode		: 1;
	u8 vmap_active	: 1;

	// Encoder Switch
	u8								 sw_mode;
	eeprom_proto_cfg_s sw_cfg;

	struct {
		eeprom_proto_cfg_s cfg;
		u8								 rgb_r;
		u8								 rgb_g;
		u8								 rgb_b;
		uint16_t					 hsv_h; // Hue (0-1535)
		u8								 hsv_s; // Saturation (0-255)
		u8								 hsv_v; // Value (0-255)
		u8								 rb_r;
		u8								 rb_b;
	} vmap[NUM_VMAPS_PER_ENC];
};

struct eeprom {
	u16										version;
	u8										reset_pending; // Flag to indicate pending config reset
	struct eeprom_encoder encoders[NUM_ENC_BANKS][NUM_ENCODERS];
};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

static int encode_encoder(const struct encoder*	 src,
													struct eeprom_encoder* dst);
static int decode_encoder(const struct eeprom_encoder* src,
													struct encoder*							 dst);
static int decode_proto_cfg(const eeprom_proto_cfg_s* src,
														struct proto_cfg*					dst);
static int encode_proto_cfg(const struct proto_cfg* src,
														eeprom_proto_cfg_s*			dst);
static int init_eeprom(void);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */

/*
	The EEMEM flag is used to store the data in the eeprom memory.
	It adds a linker flag to the data structure to ensure that the linker
	knows the data is only in eeprom

	After linking it is possible to see the memory usage for the eeprom:

	[84/84] Linking C executable neosam.elf
	Memory region         Used Size  Region Size  %age Used
							text:       18640 B       136 KB     13.38%
							data:        5596 B         8 KB     68.31%
						eeprom:         384 B         2 KB     18.75%
	...

	On a completely new device the EEPROM will be initialised with basic values.

	---

	Note - No runtime data is allocated for this variable.
	Note - This variable can be used for reading and writing. The compiler
	can determine the eeprom memoryn addresses to write to if you use
	the appropriate eeprom_read/write/update functions with this variable
	as the source/destination.
*/
EEMEM struct eeprom eeprom_data;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

int cfg_init(bool reset_cfg) {
	// Check if the eeprom is initialised (the first word == EE_VERSION), if not
	// initialise the eeprom with default values
	u16 version		 = eeprom_read_word(&eeprom_data.version);
	u8	reset_flag = eeprom_read_byte(&eeprom_data.reset_pending);

	if (reset_flag == 1 || reset_cfg == 1 || version != EE_VERSION) {
		return init_eeprom(); // This will also clear the reset_pending flag
	}

	return SUCCESS;
}

int cfg_load(void) {
	// Load encoder banks
	for (int i = 0; i < NUM_ENC_BANKS; i++) {
		for (int j = 0; j < NUM_ENCODERS; j++) {
			struct eeprom_encoder ee_enc = {0};
			eeprom_read_block(&ee_enc, &eeprom_data.encoders[i][j],
												sizeof(struct eeprom_encoder));
			decode_encoder(&ee_enc, &gENCODERS[i][j]);
		}
	}

	return SUCCESS;
}

int cfg_store(void) {
	// Encode all configuration data to the eeprom data structure

	for (int i = 0; i < NUM_ENC_BANKS; i++) {
		for (int j = 0; j < NUM_ENCODERS; j++) {
			struct eeprom_encoder enc = {0};
			encode_encoder(&gENCODERS[i][j], &enc);
			eeprom_update_block(&enc, &eeprom_data.encoders[i][j],
													sizeof(struct eeprom_encoder));
		}
	}

	return SUCCESS;
}

int cfg_update(void) {
	static uint32_t last_update = 0;
	uint32_t				time_now		= systime_ms();

	// Update every 1 second if something has changed
	if ((time_now - last_update) > 5000) {
		cfg_store();
		last_update = time_now;
	}

	return SUCCESS;
}

int mf_cfg_reset(void) {
	// Set the reset pending flag in EEPROM. The actual data reset happens on next
	// boot.
	eeprom_update_byte(&eeprom_data.reset_pending, 1);
	hal_system_reset(); // This function does not return
	return SUCCESS;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */

static int encode_encoder(const struct encoder*	 src,
													struct eeprom_encoder* dst) {
	dst->display_mode = src->display.mode;
	dst->virtmap_mode = src->display.virtmode;
	dst->detent				= src->detent;
	dst->vmap_mode		= src->vmap_mode;
	dst->sw_mode			= src->sw_mode;
	dst->vmap_active	= src->vmap_active;

	for (int i = 0; i < NUM_VMAPS_PER_ENC; i++) {
		// Save RGB and HSV color values
		dst->vmap[i].rgb_r = src->vmaps[i].rgb.red;
		dst->vmap[i].rgb_g = src->vmaps[i].rgb.green;
		dst->vmap[i].rgb_b = src->vmaps[i].rgb.blue;

		// Add saving of HSV values
		dst->vmap[i].hsv_h = src->vmaps[i].hsv.hue;
		dst->vmap[i].hsv_s = src->vmaps[i].hsv.saturation;
		dst->vmap[i].hsv_v = src->vmaps[i].hsv.value;

		dst->vmap[i].rb_r = src->vmaps[i].rb.red;
		dst->vmap[i].rb_b = src->vmaps[i].rb.blue;
		encode_proto_cfg(&src->vmaps[i].cfg, &dst->vmap[i].cfg);
	}

	encode_proto_cfg(&src->sw_cfg, &dst->sw_cfg);

	return SUCCESS;
}

static int decode_encoder(const struct eeprom_encoder* src,
													struct encoder*							 dst) {
	dst->display.mode			= src->display_mode;
	dst->display.virtmode = src->virtmap_mode;
	dst->detent						= src->detent;
	dst->vmap_mode				= src->vmap_mode;
	dst->sw_mode					= src->sw_mode;
	dst->vmap_active			= src->vmap_active;

	for (int i = 0; i < NUM_VMAPS_PER_ENC; i++) {
		// Load RGB values
		dst->vmaps[i].rgb.red		= src->vmap[i].rgb_r;
		dst->vmaps[i].rgb.green = src->vmap[i].rgb_g;
		dst->vmaps[i].rgb.blue	= src->vmap[i].rgb_b;

		// Load HSV values
		dst->vmaps[i].hsv.hue				 = src->vmap[i].hsv_h;
		dst->vmaps[i].hsv.saturation = src->vmap[i].hsv_s;
		dst->vmaps[i].hsv.value			 = src->vmap[i].hsv_v;

		// Update RGB values from HSV values to ensure consistency
		color_update_vmap_rgb(&dst->vmaps[i]);

		dst->vmaps[i].rb.red	= src->vmap[i].rb_r;
		dst->vmaps[i].rb.blue = src->vmap[i].rb_b;
		decode_proto_cfg(&src->vmap[i].cfg, &dst->vmaps[i].cfg);
	}

	decode_proto_cfg(&src->sw_cfg, &dst->sw_cfg);
	return SUCCESS;
}

static int decode_proto_cfg(const eeprom_proto_cfg_s* src,
														struct proto_cfg*					dst) {
	switch (src->type) {
		case PROTOCOL_NONE: memset(dst, 0, sizeof(struct proto_cfg)); break;

		case PROTOCOL_OSC:
			// Not implemented
			break;

		case PROTOCOL_MIDI:
			dst->type					= PROTOCOL_MIDI;
			dst->midi.mode		= src->midi.mode;
			dst->midi.channel = src->midi.channel;
			dst->midi.raw			= src->midi.raw;
			break;

		default: return ERR_UNSUPPORTED;
	}

	return SUCCESS;
}

static int encode_proto_cfg(const struct proto_cfg* src,
														eeprom_proto_cfg_s*			dst) {
	switch (src->type) {
		case PROTOCOL_NONE: memset(dst, 0, sizeof(eeprom_proto_cfg_s)); break;

		case PROTOCOL_OSC:
			// Not implemented
			break;

		case PROTOCOL_MIDI:
			dst->midi.mode		= src->midi.mode;
			dst->midi.channel = src->midi.channel;
			dst->midi.raw			= src->midi.raw;
			break;

		default: return ERR_UNSUPPORTED;
	}

	return SUCCESS;
}

static int init_eeprom(void) {
	// Erase the eeprom
	for (int i = 0; i < sizeof(struct eeprom); i++) {
		eeprom_write_byte((uint8_t*)i, 0);
	}

	// Write the magic number
	eeprom_write_word(&eeprom_data.version, EE_VERSION);

	// Clear the reset pending flag
	eeprom_write_byte(&eeprom_data.reset_pending,
										0); // Use write_byte as EEPROM is already erased to 0xFF

	// Write the initial state of the system to the eeprom
	int ret = cfg_store();

	// Send EVT_SYS_RES_CFG_RESET event
	struct sys_event evt = {.type = EVT_SYS_RES_CFG_RESET, .data.ret = ret};
	event_post(EVENT_CHANNEL_SYS, &evt);
	return ret;
}
// filepath: ./hal/timer.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <avr/io.h>
#include <avr/pgmspace.h>
#include <util/atomic.h>

#include "hal/timer.h"

#include "system/types.h"
#include "system/error.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

static u8						get_bitmask(enum timer_peripheral periph);
static register8_t* get_power_reg(enum timer_peripheral periph);

static int pwm_get_params(u16 freq, TC_CLKSEL_t* clk, u16* per);

static void cc_buffer_set(struct timer_config* cfg, u16 val);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

int timer_init(struct timer_config* cfg) {
	assert(cfg);

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
		register8_t* pp = get_power_reg(cfg->periph);
		*pp &= ~get_bitmask(cfg->periph); // Enable power to timer peripheral

		switch (cfg->mode) {

			case TIMER_MODE_OVF: {
				// Set waveform generation mode
				cfg->timer->CTRLB |= TC_WGMODE_NORMAL_gc;

				// Configure timer period and divisor
				u16					period;
				TC_CLKSEL_t clk_sel;

				timer_get_parameters((unsigned int)cfg->freq, &clk_sel, &period);
				cfg->timer->CTRLA |= (u8)clk_sel;
				cfg->timer->PER = period;
				break;
			}

			case TIMER_MODE_PWM: {
				// Configure timer period and divisor
				TC_CLKSEL_t clk_sel = 0;
				u16					period	= 0;

				int status = pwm_get_params(cfg->pwm.freq, &clk_sel, &period);
				RETURN_ON_ERR(status);

				// Set the timer compare channel buffer for the desired duty %
				timer_pwm_set_duty(cfg, cfg->pwm.duty);

				// Set config parameters
				cfg->timer->CTRLB |= TC_WGMODE_SINGLESLOPE_gc;
				cfg->timer->CTRLB |= (TC0_CCAEN_bm << (cfg->channel));
				cfg->timer->PER = period;

				// // Enable output on port direction
				// PORTD.DIR |= (1u << cfg->channel);

				// Set clock source (starts the timer)
				cfg->timer->CTRLA |= (u8)clk_sel;
				break;
			}
			case TIMER_MODE_NB:
			default: return ERR_BAD_PARAM;
		}
	} // ATOMIC_BLOCK(ATOMIC_RESTORESTATE)

	return 0;
}

u16 timer_getval(struct timer_config* cfg) {
	return cfg->timer->CNT;
}

void timer_ch_isr_enable(struct timer_config* cfg, enum isr_priority priority) {
	assert(cfg);

	const u8 shift = (u8)cfg->channel << 1;
	const u8 mask	 = (TC0_CCAINTLVL_gm) << shift;
	cfg->timer->INTCTRLB =
			(u8)(cfg->timer->INTCTRLB & ~mask) | (u8)(priority << shift);
}

void timer_ch_isr_disable(struct timer_config* cfg) {
	assert(cfg);
	const u8 shift = (u8)cfg->channel << 2;
	const u8 mask	 = (TC0_CCAINTLVL_gm) << shift;
	cfg->timer->INTCTRLB &= ~mask;
}

void timer_ovr_isr_enable(struct timer_config* cfg,
													enum isr_priority		 priority) {
	assert(cfg);
	cfg->timer->INTCTRLA =
			(cfg->timer->INTCTRLA & (u8)~TC0_OVFINTLVL_gm) | (u8)priority;
}

void timer_ovr_isr_disable(struct timer_config* cfg) {
	assert(cfg);
	cfg->timer->INTCTRLA &= (u8)~TC0_OVFINTLVL_gm;
}

void timer_pwm_set_duty(struct timer_config* cfg, u8 duty) {
	assert(cfg);

	if (duty > 100) {
		duty = 100;
	}

	cfg->pwm.duty = duty;
	u16 ccbuf			= (cfg->timer->PER * duty) / 100;
	cc_buffer_set(cfg, ccbuf);
}

#warning "TODO"
void timer_pwm_stop(struct timer_config* cfg) {
	(void)cfg;
}

#warning "TODO"
void timer_pwm_start(struct timer_config* cfg) {
	(void)cfg;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~
 */

#define NUM_PRESCALERS (sizeof(prescalers) / sizeof(prescalers[0]))
#define MAX_PER				 UINT16_MAX

#pragma GCC diagnostic ignored "-Wsign-conversion"
#pragma GCC diagnostic ignored "-Wconversion"
void timer_get_parameters(unsigned int freq, TC_CLKSEL_t* clk_sel,
													u16* period) {
	PROGMEM static const u32 prescalers[]		 = {1, 2, 4, 8, 64, 256, 1024};
	const u32								 clocks_per_tick = F_CPU / freq;
	u32											 lowest_error		 = UINT32_MAX;
	u32											 per						 = 0;
	u16											 best_per				 = 0;

	u8 i = 0;

	for (; i < NUM_PRESCALERS; ++i) {
		per = clocks_per_tick / prescalers[i];
		per--;
		if (per > MAX_PER)
			continue;

		u32 error;

		error = abs(clocks_per_tick - ((per + 1u) * prescalers[i]));
		if (error < lowest_error) {
			lowest_error = error;
			best_per		 = per;
		}
	}

	*clk_sel = (TC_CLKSEL_t)i + 1;
	*period	 = best_per;
}
#pragma GCC diagnostic pop

static u8 get_bitmask(enum timer_peripheral periph) {
	switch (periph) {
		case TIMER_TCE0:
		case TIMER_TCC0:
		case TIMER_TCC2:
		case TIMER_TCD0:
		case TIMER_TCD2: {
			return PR_TC0_bm;
		}
		case TIMER_TCC1:
		case TIMER_TCD1: {
			return PR_TC1_bm;
		}

		default: return 0;
	}

	return 0;
}

static register8_t* get_power_reg(enum timer_peripheral periph) {
	switch (periph) {
		case TIMER_TCC0:
		case TIMER_TCC1:
		case TIMER_TCC2: {
			return &PR.PRPC;
		}

		case TIMER_TCD0:
		case TIMER_TCD1:
		case TIMER_TCD2: {
			return &PR.PRPD;
		}

		case TIMER_TCE0: {
			return &PR.PRPE;
		}

		default: return NULL;
	}
	return NULL;
}

/**
 * @brief Determine the correct clock divisor and period settings to
 * use for a timer peripheral, based on a required PWM frequency.
 *
 * Pass two pointers to the function to store the calculated parameters.
 * Check the return code for 0 to ensure success.
 *
 * @param frequency Desired PWM switching frequency.
 * @param clk Calculated divisor.
 * @param per Calculated period
 * @return int 0 = success, anything else = failure.
 */
static int pwm_get_params(u16 freq, TC_CLKSEL_t* clk, u16* per) {
	assert(clk);
	assert(per);

	if (freq == 0) {
		return ERR_BAD_PARAM;
	}

	u16 period;
	u8	prescaler;

	// calculate the best period and prescaler for the desired PWM frequency
	for (prescaler = 1; prescaler <= 7; prescaler++) {
		period = (u16)(F_CPU / (freq * prescaler));
		if (period <= 0xFFFF) {
			break;
		}
	}

	*per = period;
	*clk = prescaler;

	return 0;
}

static void cc_buffer_set(struct timer_config* cfg, u16 val) {
	assert(cfg);

	switch (cfg->channel) {

		case TIMER_CHANNEL_A: {
			cfg->timer->CCABUF = val;
			break;
		}

		case TIMER_CHANNEL_B: {
			cfg->timer->CCBBUF = val;
			break;
		}

		case TIMER_CHANNEL_C: {
			cfg->timer->CCCBUF = val;
			break;
		}

		case TIMER_CHANNEL_D: {
			cfg->timer->CCDBUF = val;
			break;
		}

		default: return;
	}
}
// filepath: ./hal/sys.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2025) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "hal/sys.h"
#include <avr/interrupt.h>
#include <avr/wdt.h>
#include <util/atomic.h>

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

__attribute__((noreturn)) void hal_system_reset(void) {
	// Disable interrupts to prevent interference during reset sequence
	cli();

	// Ensure WDT is disabled before changing configuration
	// This requires Configuration Change Protection (CCP)
	CCP			 = CCP_IOREG_gc;
	WDT.CTRL = 0x00; // Disable WDT

	// Wait for synchronization if necessary (usually very short)
	while (WDT.STATUS & WDT_SYNCBUSY_bm)
		;

	// Configure WDT for shortest timeout period (e.g., 8ms) and enable Reset mode
	// WDT_PER_8CLK_gc is the shortest, but might be too fast. Let's use 8ms.
	// WDT_ENABLE_bm enables the WDT
	// WDT_CEN_bm allows changing the WDT settings
	CCP			 = CCP_IOREG_gc;
	WDT.CTRL = WDT_PER_8CLK_gc | WDT_ENABLE_bm | WDT_CEN_bm;

	// Wait indefinitely for the WDT to reset the MCU
	while (1)
		;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./hal/boot.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <avr/io.h>
#include <avr/wdt.h>

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define BOOTKEY 0x99C0FFEE

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

void bootloader_check(void);
void bootloader_start(void);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */

// The boot key is placed in the no init section - it will not be initialised by
// crt0, meaning that its value will be retained AFTER a soft-reset. The boot
// key is checked at system startup and if its value matches BOOTKEY then the
// bootloader execution will jump to the bootloader.
__attribute__((section(".noinit"))) static uint32_t boot_key;

// This is a pointer to the reset interrupt vector of the bootloader, which is
// located at this specific location (as per the Atmel application note.)
void (*bootloader)(void) = (void (*)(void))(BOOT_SECTION_START / 2 + 0x1FC / 2);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

void bootloader_check(void) {
	// Check if the reset was caused by the watchdog timer, and that the bootkey
	// is valid.
	if (((RST.STATUS & RST_WDRF_bm)) && (boot_key == BOOTKEY)) {
		boot_key = 0; // Reset the bootkey to stop a bootloader loop.

		/**
		 * Copied from the GCC AVR options documentation -
		 * https://gcc.gnu.org/onlinedocs/gcc-6.3.0/gcc/AVR-Options.html In
		 * order to facilitate indirect jump on devices with more than 128 Ki
		 * bytes of program memory space, there is a special function register
		 * called EIND that serves as most significant part of the target
		 * address when EICALL or EIJMP instructions are used.
		 * */
		EIND = BOOT_SECTION_START >> 17;
		bootloader();
	}
}

/*
	This function starts the watchdog timer and then enters an infinite loop.
	The watchdog timer will reset the AVR after 30ms as the system did not
	"pet the dog". The bootloader_check function will then be called during
	the system startup (after reset), and because the bootkey was set to
	the required value, the bootloader will be executed.
*/
void bootloader_start(void) {
	// USB_Disable();
	// IRQ_DisableInterrupts();
	boot_key = BOOTKEY;
	wdt_enable(WDTO_30MS);
	while (1) {}
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./hal/dma.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <avr/io.h>
#include <util/atomic.h>

#include "hal/dma.h"

#include "system/types.h"
#include "system/error.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

void dma_peripheral_init(void) {
	ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
		PR.PRGEN &= (u8)~PR_DMA_bm;			// Enable power to the DMA controller
		DMA.CTRL &= (u8)~DMA_ENABLE_bm; // Disable
		DMA.CTRL |= DMA_RESET_bm;				// Reset (all registers cleared)
		DMA.CTRL |= DMA_ENABLE_bm;			// Enable
	}
}

int dma_channel_init(DMA_CH_t* ch, struct dma_channel_cfg* cfg) {
	if (ch == NULL || cfg == NULL) {
		return ERR_NULL_PTR;
	}

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
		ch->CTRLA &= (u8)~DMA_CH_ENABLE_bm; // Disable DMA channel
		ch->CTRLA |= DMA_CH_RESET_bm;				// Reset the channel (and registers)

		// Source configuration
		ch->SRCADDR0 = (u8)(cfg->src_ptr >> 0) & 0xFF;
		ch->SRCADDR1 = (u8)(cfg->src_ptr >> 8) & 0xFF;
		// ch->SRCADDR2 = (cfg->src_ptr >> 16) & 0xFF;

		ch->ADDRCTRL |= (u8)cfg->src_addr_mode;
		ch->ADDRCTRL |= (u8)cfg->src_reload_mode;

		// Destination configuration
		ch->DESTADDR0 = (u8)(cfg->dst_ptr >> 0) & 0xFF;
		ch->DESTADDR1 = (u8)(cfg->dst_ptr >> 8) & 0xFF;
		// ch->DESTADDR2 = (cfg->dst_ptr >> 16) & 0xFF;

		ch->ADDRCTRL |= (u8)cfg->dst_addr_mode;
		ch->ADDRCTRL |= (u8)cfg->dst_reload_mode;

		// Configure the transaction
		ch->TRIGSRC = cfg->trig_source;
		ch->CTRLA |= (u8)cfg->burst_len;
		ch->TRFCNT = (register16_t)cfg->block_size;

		if (cfg->repeat_count > 1) {
			ch->REPCNT = cfg->repeat_count;
			ch->CTRLA |= DMA_CH_REPEAT_bm;
		} else {
			ch->CTRLA |= DMA_CH_SINGLE_bm;
		}

		ch->CTRLB |= (u8)((cfg->err_prio << DMA_CH_ERRINTLVL_gp) |
											(cfg->int_prio << DMA_CH_TRNINTLVL_gp));

		/**
		 * Set the double buffer mode for the DMA controller.
		 * If enabled - this will "interlink" DMA channel 0 and 1, or channel 2
		 * and 3 After the primary channel is complete the secondary channel
		 * will fire a dma transaction, which then re-enables the primary
		 * channel...
		 */
		DMA.CTRL = (DMA.CTRL & (u8)~DMA_DBUFMODE_gm) | (u8)cfg->dbuf_mode;

		// Enable Channel
		ch->CTRLA |= DMA_CH_ENABLE_bm;
	} //   ATOMIC_BLOCK(ATOMIC_RESTORESTATE)

	return 0;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./hal/signature.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2025) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* Reads the production signature row (calibration data) from NVM. */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#include <avr/io.h>
#include <avr/cpufunc.h>
#include "hal/signature.h"
#include "system/types.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define PRODUCTION_SIGNATURE_SIZE sizeof(NVM_PROD_SIGNATURES_t)

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

static uint8_t nvm_read_prod_sig_byte(uint16_t address);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

void signature_read(NVM_PROD_SIGNATURES_t* prod_sig) {
	uint8_t* dest_ptr = (uint8_t*)prod_sig; // Treat the struct as a byte array
	uint16_t i;

	for (i = 0; i < PRODUCTION_SIGNATURE_SIZE; ++i) {
		dest_ptr[i] = nvm_read_prod_sig_byte(i);
	}
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */

/**
 * @brief Reads a single byte from the production signature row (calibration
 * row).
 *
 * @param address The byte offset within the production signature row (0-63).
 * @return uint8_t The byte read from the specified address.
 */
static uint8_t nvm_read_prod_sig_byte(uint16_t address) {
	uint8_t byte_value;

	// Wait until NVM controller is ready (not busy).
	while (NVM.STATUS & NVM_NVMBUSY_bm) {
		; // Wait
	}

	// Set the NVM command to read the calibration/production signature row.
	// This requires Configuration Change Protection (CCP).
	_PROTECTED_WRITE(NVM.CMD, NVM_CMD_READ_CALIB_ROW_gc);

	// Use inline assembly to perform the Load Program Memory (LPM) instruction.
	// The Z-pointer register (R31:R30) must point to the address (byte offset)
	// within the signature row to be read.
	__asm__ __volatile__(
			"lpm %0, Z\n"
			: "=r"(byte_value) // Output: store result in byte_value register
			: "z"(address)		 // Input: load 'address' into Z-pointer (R31:R30)
	);

	// After the LPM instruction, it's good practice to clear the NVM command.
	// This also requires CCP.
	_PROTECTED_WRITE(NVM.CMD, NVM_CMD_NO_OPERATION_gc);

	return byte_value;
}
// filepath: ./hal/init.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <avr/io.h>
#include <avr/wdt.h>

#include "LUFA/Common/Common.h"
#include "LUFA/Drivers/USB/USB.h"
#include "LUFA/Platform/XMEGA/ClockManagement.h"

#include "hal/adc.h"
#include "hal/dma.h"
#include "hal/init.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

void avr_xmega128a4u_init(void) {
	wdt_disable();

	// TODO - this relies on LUFA init functionality, but what if another
	// USB stack is used? need to add the init functionality to the HAL.

	// Initialise system clocks
	XMEGACLK_StartPLL(CLOCK_SRC_INT_RC2MHZ, 2000000, F_CPU);
	XMEGACLK_SetCPUClockSource(CLOCK_SRC_PLL);
	XMEGACLK_StartInternalOscillator(CLOCK_SRC_INT_RC32MHZ);
	XMEGACLK_StartDFLL(CLOCK_SRC_INT_RC32MHZ, DFLL_REF_INT_USBSOF, F_USB);

	// Configure interrupt controller
	PMIC.CTRL = PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_HILVLEN_bm;

	// Initialise peripherals
	dma_peripheral_init();

	// Initialise the ADC
	adc_init(ADC_REF_INT1V, ADC_RES_12BIT, ADC_PRESCALER_DIV64);
	adc_channel_config_internal(ADC_CH0, ADC_CH_MUXINT_TEMP);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./hal/gpio.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include "system/types.h"
#include "hal/gpio.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#define PIN_MASK(x) (1u << ((x) & 0x07))

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

void gpio_mode(PORT_t* port, u8 pin, PORT_OPC_t mode) {
	assert(port);

	// Get pointer to pin register
	volatile u8* ctrl = (&port->PIN0CTRL + PIN_MASK(pin));

	*ctrl &= (u8)~PORT_ISC_gm; // Clear the mode
	*ctrl |= (u8)mode;				 // Set the mode
}

void gpio_dir(PORT_t* port, u8 pin, enum gpio_dir dir) {
	assert(port);

	if (dir == GPIO_INPUT) {
		port->DIRCLR = PIN_MASK(pin);
	} else if (dir == GPIO_OUTPUT) {
		port->DIRSET = PIN_MASK(pin);
	}
}

void gpio_set(PORT_t* port, u8 pin, u8 state) {
	assert(port);

	if (state) {
		port->OUTSET = PIN_MASK(pin);
	} else {
		port->OUTCLR = PIN_MASK(pin);
	}
}

u8 gpio_get(PORT_t* port, u8 pin) {
	assert(port);
	return port->IN & PIN_MASK(pin);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
// filepath: ./hal/adc.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2025) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai                */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
#include <avr/io.h>
#include <util/delay.h>
#include <stdint.h>
#include <stdbool.h>
#include "hal/signature.h"
#include "hal/adc.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* Constants for temperature sensor conversion */
#define ADC_TEMP_FACTOR (1.0f / 1.13f) /* Temperature coefficient */
#define ADC_TEMP_OFFSET (-272.8f)			 /* Temperature offset value */

/* Base address for production signature row access (adjust if needed) */
/* NOTE: Direct pointer access to signature row might not be portable or
	 reliable. Using NVM controller commands or specific toolchain functions
	 (e.g., boot_signature_byte_get) is generally safer. This implementation
	 follows the pattern in the original code. */
#define PROD_SIGNATURES_BASE                                                   \
	0x00 // Assuming base address, check datasheet/toolchain

/* Offsets for calibration bytes within the signature row */
#define ADCACAL0_OFFSET 0x20
#define ADCACAL1_OFFSET 0x21
// #define TEMPSENSE0_OFFSET 0x2E // Not used in current simple temp formula
// #define TEMPSENSE1_OFFSET 0x2F // Not used in current simple temp formula

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
static void adc_wait_for_channel(adc_channel_t channel);
static void adc_load_calibration(void);
static void adc_apply_calibration(void);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
static ADC_CH_t* adc_get_channel_ptr(adc_channel_t ch);

// Store calibration values read from signature row
static uint8_t adca_cal0;
static uint8_t adca_cal1;
static uint8_t tempsense0;
static uint8_t tempsense1;

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */
/**
 * @brief Initialize the ADC module
 *
 * This function initializes the ADC module with the specified
 * reference, resolution, and prescaler. It also applies calibration
 * values read from production signatures row.
 */
void adc_init(adc_reference_t reference, adc_resolution_t resolution,
							adc_prescaler_t prescaler) {
	static bool initialized = false;

	if (initialized) {
		/* ADC already initialized, no need to reconfigure */
		return;
	}
	/* Disable the ADC before configuring */
	ADCA.CTRLA &= (uint8_t)(~(uint8_t)ADC_ENABLE_bm);

	/* Load calibration data from signature row */
	adc_load_calibration();

	/* Set up the ADC control registers */
	ADCA.CTRLB =
			(ADCA.CTRLB & (uint8_t)(~(uint8_t)ADC_RESOLUTION_gm)) | resolution;
	ADCA.REFCTRL =
			(ADCA.REFCTRL & (uint8_t)(~(uint8_t)ADC_REFSEL_gm)) | reference;
	ADCA.PRESCALER =
			(ADCA.PRESCALER & (uint8_t)(~(uint8_t)ADC_PRESCALER_gm)) | prescaler;

	/* Set current limit to ensure accuracy at higher sample rates */
	ADCA.CTRLB |= ADC_CURRLIMIT_HIGH_gc;

	/* Apply calibration values */
	adc_apply_calibration();

	/* Enable the ADC module */
	ADCA.CTRLA |= ADC_ENABLE_bm;

	/* Wait for ADC to stabilize */
	_delay_us(10);

	/* Wait for ADC to be ready (check if enable bit is set in CTRLA) */
	while (!(ADCA.CTRLA & ADC_ENABLE_bm))
		;
}

/**
 * @brief Configure an ADC channel
 *
 * This function configures the specified ADC channel with the given
 * input mode, gain, and positive input.
 */
void adc_channel_config(adc_channel_t ch, adc_ch_input_mode_t input_mode,
												adc_ch_gain_t gain, uint8_t positive_input) {
	ADC_CH_t* adc_ch = adc_get_channel_ptr(ch);

	/* Configure the channel's control register */
	adc_ch->CTRL = (adc_ch->CTRL &
									(uint8_t)(~(uint8_t)(ADC_CH_INPUTMODE_gm | ADC_CH_GAIN_gm))) |
								 input_mode;

	/* Set gain if using differential with gain */
	if (input_mode == ADC_CH_INPUTMODE_DIFFWGAIN) {
		adc_ch->CTRL |= gain;
	}

	/* Set the positive input pin */
	/* Clear MUX settings first */
	adc_ch->MUXCTRL = 0;
	adc_ch->MUXCTRL = (adc_ch->MUXCTRL & (uint8_t)(~(uint8_t)ADC_CH_MUXPOS_gm)) |
										positive_input;

	/* For single-ended measurements, INPUTMODE setting handles negative input.
		 No need to explicitly set MUXNEG. */
}

/**
 * @brief Configure an ADC channel for internal input
 *
 * This function sets up a channel to read from internal sources like
 * the temperature sensor, bandgap reference, etc.
 */
void adc_channel_config_internal(adc_channel_t					 ch,
																 adc_ch_internal_input_t input) {
	ADC_CH_t* adc_ch = adc_get_channel_ptr(ch);

	/* Set input mode to internal */
	adc_ch->CTRL = (adc_ch->CTRL & (uint8_t)(~(uint8_t)ADC_CH_INPUTMODE_gm)) |
								 ADC_CH_INPUTMODE_INTERNAL_gc;

	/* Configure the internal input mux */
	adc_ch->MUXCTRL =
			(adc_ch->MUXCTRL & (uint8_t)(~(uint8_t)ADC_CH_MUXINT_gm)) | input;
}

/**
 * @brief Start a conversion on an ADC channel
 */
void adc_start_conversion(adc_channel_t ch) {
	ADC_CH_t* adc_ch = adc_get_channel_ptr(ch);

	/* Set channel start conversion bit */
	adc_ch->CTRL |= ADC_CH_START_bm;
}

/**
 * @brief Check if a conversion is complete on an ADC channel
 *
 * @return true if the conversion is complete, false otherwise
 */
bool adc_is_conversion_complete(adc_channel_t ch) {
	/* Check the corresponding interrupt flag */
	switch (ch) {
		case ADC_CH0: return (ADCA.INTFLAGS & ADC_CH0IF_bm) != 0;
		case ADC_CH1: return (ADCA.INTFLAGS & ADC_CH1IF_bm) != 0;
		case ADC_CH2: return (ADCA.INTFLAGS & ADC_CH2IF_bm) != 0;
		case ADC_CH3: return (ADCA.INTFLAGS & ADC_CH3IF_bm) != 0;
		default: return false;
	}
}

/**
 * @brief Read the result of a conversion on an ADC channel
 *
 * This function reads and returns the ADC result after a conversion.
 * The result format depends on the resolution setting.
 */
uint16_t adc_read_result(adc_channel_t ch) {
	uint16_t result;

	/* Get the result based on channel number */
	switch (ch) {
		case ADC_CH0: result = ADCA.CH0RES; break;
		case ADC_CH1: result = ADCA.CH1RES; break;
		case ADC_CH2: result = ADCA.CH2RES; break;
		case ADC_CH3: result = ADCA.CH3RES; break;
		default: result = 0; break;
	}

	/* Clear the corresponding interrupt flag */
	switch (ch) {
		case ADC_CH0: ADCA.INTFLAGS = ADC_CH0IF_bm; break;
		case ADC_CH1: ADCA.INTFLAGS = ADC_CH1IF_bm; break;
		case ADC_CH2: ADCA.INTFLAGS = ADC_CH2IF_bm; break;
		case ADC_CH3: ADCA.INTFLAGS = ADC_CH3IF_bm; break;
		default: break;
	}

	return result;
}

/**
 * @brief Perform a single conversion and return the result
 *
 * This function starts a conversion, waits for it to complete,
 * and returns the result.
 */
uint16_t adc_get_sample(adc_channel_t ch) {
	/* Start the conversion */
	adc_start_conversion(ch);

	/* Wait for conversion to complete */
	adc_wait_for_channel(ch);

	/* Return the conversion result */
	return adc_read_result(ch);
}

/**
 * @brief Read the temperature sensor and convert to degrees Celsius
 *
 * This function reads the internal temperature sensor and converts the
 * ADC reading to a temperature in degrees Celsius using the factory
 * calibration values stored in the production signature row.
 *
 * The conversion formula from the XMEGA datasheet is:
 * Temperature (C) = ((ADC reading - TEMPSENSE0) * TEMPSENSE1) / 256 + 25C
 *
 * @return float The temperature in degrees Celsius with decimal precision
 */
float adc_read_temperature_float(void) {
	uint16_t							adc_value;
	float									temperature;
	NVM_PROD_SIGNATURES_t sig_data;

	/* Read calibration values from signature row */
	signature_read(&sig_data);

	/* Configure channel 0 for temperature measurement */
	adc_channel_config_internal(ADC_CH0, ADC_CH_MUXINT_TEMP);

	/* Get ADC reading */
	adc_value = adc_get_sample(ADC_CH0);

	/*
	 * Calculate temperature using calibration values from signature row.
	 * Formula from XMEGA datasheet:
	 * Temperature = ((ADC reading - TEMPSENSE0) * TEMPSENSE1) / 256 + 25C
	 */

	/* Using floating point for more precision */
	temperature = ((float)adc_value - (float)sig_data.TEMPSENSE0);
	temperature = (temperature * (float)sig_data.TEMPSENSE1) / 256.0f + 25.0f;

	return temperature;
}

/**
 * @brief Read the temperature sensor and convert to degrees Celsius
 *
 * This function reads the internal temperature sensor and converts the
 * ADC reading to a temperature in degrees Celsius using the factory
 * calibration values stored in the production signature row.
 *
 * The conversion formula from the XMEGA datasheet is:
 * Temperature (C) = ((ADC reading - TEMPSENSE0) * TEMPSENSE1) / 256 + 25C
 *
 * @return int16_t The temperature in degrees Celsius (can be negative)
 */
int16_t adc_read_temperature(void) {
	/* Call the floating point version and round to integer */
	float temp = adc_read_temperature_float();
	return (int16_t)(temp + 0.5f); /* Round to nearest integer */
}

/**
 * @brief Enable the ADC
 */
void adc_enable(void) {
	ADCA.CTRLA |= ADC_ENABLE_bm;
}

/**
 * @brief Disable the ADC
 */
void adc_disable(void) {
	ADCA.CTRLA &= (uint8_t)(~(uint8_t)ADC_ENABLE_bm);
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/**
 * @brief Get a pointer to the channel structure
 *
 * @param ch The channel number
 * @return Pointer to the channel structure
 */
static ADC_CH_t* adc_get_channel_ptr(adc_channel_t ch) {
	switch (ch) {
		case ADC_CH0: return &ADCA.CH0;
		case ADC_CH1: return &ADCA.CH1;
		case ADC_CH2: return &ADCA.CH2;
		case ADC_CH3: return &ADCA.CH3;
		default: return &ADCA.CH0;
	}
}

/**
 * @brief Wait until conversion is complete on a channel
 */
static void adc_wait_for_channel(adc_channel_t channel) {
	uint8_t int_flags;
	uint8_t int_mask;

	/* Determine which flag to check based on channel */
	switch (channel) {
		case ADC_CH0: int_mask = ADC_CH0IF_bm; break;
		case ADC_CH1: int_mask = ADC_CH1IF_bm; break;
		case ADC_CH2: int_mask = ADC_CH2IF_bm; break;
		case ADC_CH3: int_mask = ADC_CH3IF_bm; break;
		default: int_mask = 0; break;
	}

	/* Wait for conversion to complete */
	do {
		int_flags = ADCA.INTFLAGS;
	} while (!(int_flags & int_mask));
}

/**
 * @brief Load calibration values from production signature row
 */
static void adc_load_calibration(void) {
	NVM_PROD_SIGNATURES_t prod_sig;
	signature_read(&prod_sig);
	adca_cal0 = prod_sig.ADCACAL0;
	adca_cal1 = prod_sig.ADCACAL1;

	tempsense0 = prod_sig.TEMPSENSE0;
	tempsense1 = prod_sig.TEMPSENSE1;
}

/**
 * @brief Apply loaded calibration values to ADC registers
 */
static void adc_apply_calibration(void) {
	/* Apply calibration values to the ADC calibration registers */
	ADCA.CALL = adca_cal0;
	ADCA.CALH = adca_cal1;
}
// filepath: ./hal/usart.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <avr/io.h>
#include <util/atomic.h>

#include "system/types.h"
#include "hal/usart.h"
#include "hal/gpio.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

// Missing defines for xmega usart
#define USART_UCPHA_bm (0x02) // clock phase bitmask
#define USART_DORD_bm	 (0x04) // data order bitmask

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

static u8		get_mask(USART_t* usart);
static void configure_io(USART_t* usart, enum spi_mode mode);

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

// SPI Master only
void usart_module_init(USART_t* usart, const struct usart_config* config) {
	assert(usart);
	assert(config);

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {

		// Enable power
		PR.PRPC &= ~(get_mask(usart));

		// Disable rx and tx
		usart->CTRLB &= (u8)~USART_RXEN_bm;
		usart->CTRLB &= (u8)~USART_TXEN_bm;

		// Configure IO pins
		configure_io(usart, config->mode);

		// Set to SPI Master
		usart->CTRLC |= USART_CMODE_MSPI_gc;

		// Set clock phase
		if ((config->mode == SPI_MODE_CLK_LO_PHA_HI) ||
				(config->mode == SPI_MODE_CLK_HI_PHA_HI)) {
			usart->CTRLC |= USART_UCPHA_bm;
		} else {
			usart->CTRLC &= (u8)~USART_UCPHA_bm;
		}

		// Set endianness
		if (config->endian == ENDIAN_LSB) {
			usart->CTRLC |= USART_DORD_bm;
		} else {
			usart->CTRLC &= (u8)~USART_DORD_bm;
		}

		u32 baud = 0;

		if (config->baudrate < (F_CPU / 2)) {
			baud = (F_CPU / (config->baudrate * 2)) - 1;
		}

		usart->BAUDCTRLB = (u8)((u8)(~USART_BSCALE_gm) & (baud & 0xF00) >> 8u);
		usart->BAUDCTRLA = (u8)(baud);

		// Enable
		usart->CTRLB |= USART_TXEN_bm | USART_RXEN_bm;

	} // ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
}

void usart_set_tx(USART_t* usart, bool enable) {
	assert(usart);

	if (enable) {
		usart->CTRLB |= USART_TXEN_bm;
	} else {
		usart->CTRLB &= (u8)~USART_TXEN_bm;
	}
}

void usart_set_rx(USART_t* usart, bool enable) {
	assert(usart);

	if (enable) {
		usart->CTRLB |= USART_RXEN_bm;
	} else {
		usart->CTRLB &= (u8)~USART_RXEN_bm;
	}
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */

static u8 get_mask(USART_t* usart) {
	if (usart == &USARTC0 || usart == &USARTD0 || usart == &USARTE0) {
		return PR_USART0_bm;
	} else if (usart == &USARTC1 || usart == &USARTD1) {
		return PR_USART1_bm;
	}

	return 0;
}

static void configure_io(USART_t* usart, enum spi_mode mode) {
	// Default pins are  SCK = 1, RX = 2, TX = 3
	// Remapped pins are SCK = 5, RX = 6, TX = 7

	bool		remap = false;
	PORT_t* port	= NULL;

	if (usart == &USARTC0) {
		port	= &PORTC;
		remap = (PORTC.REMAP & PORT_USART0_bm);
	} else if (usart == &USARTC1) {
		port	= &PORTC;
		remap = true;
	} else if (usart == &USARTD0) {
		port	= &PORTD;
		remap = (PORTD.REMAP & PORT_USART0_bm);
	} else if (usart == &USARTD1) {
		port	= &PORTD;
		remap = true;
	} else if (usart == &USARTE0) {
		port	= &PORTE;
		remap = (PORTE.REMAP & PORT_USART0_bm);
	}

	const u8	 sck = (remap ? 5 : 1);
	const u8	 rx	 = (remap ? 6 : 2);
	const u8	 tx	 = (remap ? 7 : 3);
	const bool invert_sck =
			(mode == SPI_MODE_CLK_HI_PHA_LO || mode == SPI_MODE_CLK_HI_PHA_HI);

	gpio_mode(port, sck, PORT_OPC_TOTEM_gc | (invert_sck ? (0x01 << 6) : 0));

	gpio_dir(port, sck, GPIO_OUTPUT);
	gpio_dir(port, rx, GPIO_INPUT);
	gpio_dir(port, tx, GPIO_OUTPUT);
	gpio_set(port, sck, 1);
}
// filepath: ./event/event.c
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                  Copyright (c) (2021 - 2023) Nicolaus Starke               */
/*                  https://github.com/nic-starke/neon_samurai               */
/*                         SPDX-License-Identifier: MIT                       */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Includes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <string.h>

#include "system/types.h"
#include "system/error.h"

#include "event/event.h"
#include "event/sys.h"
#include "event/io.h"

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Defines ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Extern ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Prototypes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Variables ~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Variables ~~~~~~~~~~~~~~~~~~~~~~~~~ */

// Data structure for general event handling
static struct event_channel* channels[EVENT_CHANNEL_NB] = {0};

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Global Functions ~~~~~~~~~~~~~~~~~~~~~~~~ */

int event_init(void) {
	// Register the core event channel
	int ret = event_channel_register(EVENT_CHANNEL_SYS, &sys_event_ch);
	RETURN_ON_ERR(ret);

	ret = event_channel_register(EVENT_CHANNEL_IO, &io_event_ch);
	RETURN_ON_ERR(ret);

	return 0;
}

int event_update(void) {

	for (uint i = 0; i < EVENT_CHANNEL_NB; i++) {
		int ret = event_channel_process(i);
		RETURN_ON_ERR(ret);
	}

	return 0;
}

int event_channel_register(enum event_ch ch, struct event_channel* def) {
	assert(def);
	assert(ch < EVENT_CHANNEL_NB);

	// Check if the channel is already registered
	if (channels[ch]) {
		return ERR_DUPLICATE;
	}

	// Validate the channel definition
	if (!def->queue || def->queue_size == 0 || def->data_size == 0) {
		return ERR_BAD_PARAM;
	}

	// Register the channel
	channels[ch] = def;

	return 0;
}

int event_channel_process(enum event_ch ch) {
	struct event_channel* channel = channels[ch];

	// Check if the channel is registered
	assert(channel);

	// Process all events in the queue
	for (uint i = 0; i < channel->head; ++i) {
		void* event = &channel->queue[i * channel->data_size];

		// Call the event handlers
		struct event_ch_handler* handler = channel->handlers;

		while (handler) {
			handler->handler(event);
			handler = handler->next;
		}
	}

	// Reset the queue head
	channel->head = 0;
	return 0;
}

int event_channel_subscribe(enum event_ch						 ch,
														struct event_ch_handler* new_handler) {
	assert(new_handler);
	assert(ch < EVENT_CHANNEL_NB);

	struct event_channel* channel = channels[ch];
	assert(channel);

	// If the channel is configured for only one subscriber
	// return an error.
	if (channel->onehandler) {
		return ERR_UNSUPPORTED;
	}

	struct event_ch_handler* curr = channel->handlers;

	// If the list is empty, add the handler to the start
	if (curr == NULL) {
		channel->handlers				= new_handler;
		channel->handlers->next = NULL;
		return 0;
	}

	// If the list is not empty then insert the new handler based on its
	// priority

	// For priority 0, the handler is added to the end of the list
	if (new_handler->priority == 0) {
		while (curr->next) {
			curr = curr->next;
		}
		curr->next = new_handler;
		return 0;
	}

	// If the priority of the new handler is higher than the first handler in
	// the list, then insert it at the start
	if (curr->priority < new_handler->priority) {
		new_handler->next = curr;
		channel->handlers = new_handler;
		return 0;
	}

	// For other priorities the handler is inserted into the correct position
	while (curr->next) {
		if (curr->next->priority < new_handler->priority) {
			new_handler->next = curr->next;
			curr->next				= new_handler;
			return 0;
		}
		curr = curr->next;
	}

	return ERR_UNSUPPORTED;
}

int event_channel_unsubscribe(enum event_ch ch, struct event_ch_handler* h) {
	assert(h);
	assert(ch < EVENT_CHANNEL_NB);

	struct event_channel* channel = channels[ch];
	assert(channel);

	if (channel->onehandler) {
		return ERR_UNSUPPORTED;
	}

	struct event_ch_handler* curr = channel->handlers;

	// If there are no more handlers then return
	if (curr == NULL) {
		return 0;
	}

	// If the first handler is the one to remove, then remove it
	if (curr == h) {
		channel->handlers = curr->next;
		return 0;
	}

	// Otherwise, iterate the list and remove the handler
	while (curr->next) {
		if (curr->next == h) {
			curr->next = curr->next->next;
			return 0;
		}
		curr = curr->next;
	}

	return ERR_UNSUPPORTED;
}

int event_post(enum event_ch ch, void* event) {
	assert(event);
	assert(ch < EVENT_CHANNEL_NB);

	struct event_channel* channel = channels[ch];
	assert(channel);

	// Check there is space in the channel event queue
	if (channel->head >= (channel->queue_size - 1)) {
		return ERR_NO_MEM;
	}

	// Add the event to the queue
	uint index = channel->head * channel->data_size;
	memcpy(&channel->queue[index], event, channel->data_size);
	channel->head++;

	return 0;
}

int event_post_rt(enum event_ch ch, void* event) {
	assert(event);
	assert(ch < EVENT_CHANNEL_NB);

	struct event_channel* channel = channels[ch];
	assert(channel);

	// Call the event handlers directly
	struct event_ch_handler* handler = channel->handlers;

	while (handler) {
		handler->handler(event);
		handler = handler->next;
	}

	return 0;
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Local Functions ~~~~~~~~~~~~~~~~~~~~~~~~~ */
